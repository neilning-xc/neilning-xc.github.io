<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="Tell the world with code"/>
    

    <!--Author-->
    
        <meta name="author" content="Neil Ning"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="React原理之从零实现简易版React"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="Tell the world with code"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Neil的博客"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="https://neilning-xc.github.io/img/banner.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="https://neilning-xc.github.io/img/banner.jpg"/>
    

    <!-- Title -->
    
    <title>React原理之从零实现简易版React - Neil的博客</title>

    <!-- Bootstrap Core CSS -->
    <link href="//lib.baomitu.com/twitter-bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//lib.baomitu.com/featherlight/1.3.5/featherlight.min.css" rel="stylesheet"/>

    <!-- Google Analytics -->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPEMLKFYYW"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-ZPEMLKFYYW');
    </script>



    <!-- favicon -->
    

<meta name="generator" content="Hexo 5.4.2"></head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Neil的博客</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                首页
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                归档
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                标签
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                分类
                            
                        </a>
                    </li>
                
                    <li>
                        <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/neilning-xc/neilning-xc.github.io">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header post-header" style="background-image: url('React原理之从零实现简易版React/bg.jpeg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>React原理之从零实现简易版React</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                            Posted by Neil Ning on
                        
                        
                            2024-12-01
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/React/">#React</a> <a href="/tags/Hooks/">#Hooks</a> <a href="/tags/Fiber/">#Fiber</a> <a href="/tags/Reconciliation/">#Reconciliation</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/学习/">学习</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>阅读React源码是一件很有意思的事情，它可以让你了解到React的设计思想，以及它是如何实现的。但是如果对React基本原理不了解，直接阅读源码会感到很吃力。所以在阅读源码之前，我们需要先了解React的基本原理。本文通过实现一个mini版React来帮助了解React的基本原理，这可以让你更好的理解React源码。React的核心功能并不难实现，本文围绕下面几个核心功能来实现一个mini版React：</p>
<ol>
<li>函数式组件</li>
<li>并发模式</li>
<li>Fiber架构</li>
<li>Reconcliation算法</li>
<li>Hooks</li>
</ol>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>这里我们使用webpack-cli来初始化一个项目。首先我们需要安装webpack-cli：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm init -y // 初始化package.json</span><br><span class="line">npm install webpack webpack-cli -D</span><br><span class="line">npx webpack-cli init</span><br></pre></td></tr></table></figure>
<p>根据提示生成一个webpack配置文件，为了能打包JSX我们直接使用@babel/preset-react预设：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @babel/preset-react -D</span><br></pre></td></tr></table></figure>
<p>然后修改.babelrc文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;modules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;@babel/preset-react&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>此时我们的项目打包环境就已经准备好了，可以开始实现mini版React了。首先创建src/index.js文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;./lib/react-slim&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">render</span>(element, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>然后创建src/lib/react-slim.js文件，初始代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib/reacts-slim.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">type, props, ...children</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">element, container</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">React</span> = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">  render</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">React</span>;</span><br></pre></td></tr></table></figure>
<p>然后需要修改index.html文件，创建容器元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来就需要实现createElement和render方法了。实现之前我们先看下index.js文件中的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>这段代码是JSX语法，它会被转换成下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;h1&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>所以我们首先实现createElement方法，它接收三个参数，返回一个虚拟Dom对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">type, props, ...children</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      <span class="attr">children</span>: children.<span class="title function_">map</span>(<span class="function"><span class="params">child</span> =&gt;</span></span><br><span class="line">        <span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span> ? child : <span class="title function_">createTextElement</span>(child) <span class="comment">// 如果是文本节点则创建文本节点</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createTextElement</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">nodeValue</span>: text,</span><br><span class="line">      <span class="attr">children</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后实现render方法，它接收两个参数，第一个是虚拟Dom对象，第二个是容器元素，通过递归的形式生成DOM树，挂在到容器元素中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">element, container</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    element.<span class="property">type</span> === <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">      ? <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : <span class="variable language_">document</span>.<span class="title function_">createElement</span>(element.<span class="property">type</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">isProperty</span> = key =&gt; key !== <span class="string">&quot;children&quot;</span>;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(element.<span class="property">props</span>)</span><br><span class="line">    .<span class="title function_">filter</span>(isProperty)</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = element.<span class="property">props</span>[name];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归渲染子节点</span></span><br><span class="line">  element.<span class="property">props</span>.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> <span class="title function_">render</span>(child, dom));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将渲染结果挂载到容器元素上 </span></span><br><span class="line">  container.<span class="title function_">appendChild</span>(dom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于是递归调用，所以函数一旦开始执行就无法暂停，这样主线程被占用，浏览器无法处理其他更高优先级的任务，如响应用户输入和动画。当有大量元素需要渲染时，用户就会感觉到明显的卡顿。所以我们需要一种能力，将渲染任务拆分成小任务，每次只渲染一小部分，然后让出主线程，这样浏览器就可以处理其他任务。其他任务完成后再继续渲染，这就是React的并发模式。</p>
<h2 id="并发模式"><a href="#并发模式" class="headerlink" title="并发模式"></a>并发模式</h2><p>我们可以通过requestIdleCallback来实现并发模式，requestIdleCallback会在浏览器空闲时执行回调函数，我们可以在回调函数中执行渲染任务。在reac-slim.js文件中添加requestIdleCallback的调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib/react-slim.js</span></span><br><span class="line"><span class="comment">// 其他代码省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>; <span class="comment">// 下一个工作单元</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoop</span>(<span class="params">deadline</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = <span class="title function_">performUnitOfWork</span>(nextUnitOfWork);</span><br><span class="line">    shouldYield = deadline.<span class="title function_">timeRemaining</span>() &lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">requestIdleCallback</span>(workLoop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">requestIdleCallback</span>(workLoop);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">nextUnitOfWork</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码使用requestIdleCallback启动一个workLoop函数，浏览器空闲时会自动调用该函数。并且会给函数传入一个deadline参数，可以调用<code>deadline.timeRemaining()</code>获取浏览器某一帧的剩余空闲时间。<br>初始时，nextUnitOfWork为null，所以workLoop函数会一直空转，我们需要在render函数中初始化nextUnitOfWork，让worLoop函数真正工作起来，修改render函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">element, container</span>) &#123;</span><br><span class="line">  nextUnitOfWork = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样render执行后，workLoop函数就会执行performUnitOfWork函数，该函数接收一个工作单元，返回下一个工作单元，在实现这个函数之前需要来了解React另外一个重要的概念：Fiber。</p>
<blockquote>
<p>由于requestIdleCallback的兼容性问题，React没有使用requestIdleCallback，而是使用了自己实现的调度器<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/facebook/react/tree/main/packages/scheduler">scheduler</a>，这里我们简化实现，使用requestIdleCallback来实现并发模式。</p>
</blockquote>
<h2 id="Fiber架构"><a href="#Fiber架构" class="headerlink" title="Fiber架构"></a>Fiber架构</h2><p>Fiber是一种链表数据结构，主要解决两方面的问题：一是能够快速找到下一个工作单元，以实现可中断的并发渲染。二是实现Reconciliation算法，使React能够在O(n)的时间复杂度内完成新旧Fiber树的Diff计算。在React中，每个元素都对应一个Fiber节点，每个Fiber节点都是一个工作单元。</p>
<p>Fiber树的结构如下图：<br><img src="/%E5%AD%A6%E4%B9%A0/React%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%89%88React/fiber.png" alt="filber"></p>
<p>Fiber树有以下几个特点：</p>
<ol>
<li>每个Fiber节点都有一个指向父Fiber节点的指针parent或者return。</li>
<li>父Fiber节点有一个指向第一个子Fiber节点的指针child。</li>
<li>Fiber节点通过sibling指针指向下一个兄弟Fiber节点。</li>
<li>每个Fiber节点都有一个指向上一个Fiber节点的指针alternate，用于保存上一次的Fiber节点。</li>
</ol>
<p>performUnitOfWork函数遍历Fiber树，返回下一个工作单元的过程如下：</p>
<ol>
<li>从根节点开始，如果当前节点有子节点，则返回子节点为下一个工作单元。</li>
<li>如果当前节点没有子节点，则需要判断是否有兄弟节点，如果有，则返回兄弟节点为下一个工作单元。</li>
<li>如果没有兄弟节点，则说明他是最后一个字节点，则需要通过parent/return属性向上查找父节点的兄弟节点，作为下一个工作单元。</li>
<li>重复步骤2和3，当Fiber树遍历完成时会回到根节点，此时整个Fiber树也构建完成。</li>
</ol>
<p>Fiber的理论知识介绍完之后，我们就可以来实现performUnitOfWork函数了。首先创建一个createDom函数，他根据Fiber节点创建DOM元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createDom</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    fiber.<span class="property">type</span> === <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">      ? <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : <span class="variable language_">document</span>.<span class="title function_">createElement</span>(fiber.<span class="property">type</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">isProperty</span> = key =&gt; key !== <span class="string">&quot;children&quot;</span>;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(fiber.<span class="property">props</span>)</span><br><span class="line">    .<span class="title function_">filter</span>(isProperty)</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = fiber.<span class="property">props</span>[name];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后开始实现performUnitOfWork函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据fiber节点创建dom</span></span><br><span class="line">  <span class="keyword">if</span> (!fiber.<span class="property">dom</span>) &#123;</span><br><span class="line">    fiber.<span class="property">dom</span> = <span class="title function_">createDom</span>(fiber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将当前fiber的dom添加到父节点中</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.<span class="property">parent</span>) &#123;</span><br><span class="line">    fiber.<span class="property">parent</span>.<span class="property">dom</span>.<span class="title function_">appendChild</span>(fiber.<span class="property">dom</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为当前fiber的子节点创建新的fiber</span></span><br><span class="line">  <span class="keyword">const</span> elements = fiber.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index];</span><br><span class="line">    <span class="comment">// 1.为父fiber创建子fiber</span></span><br><span class="line">    <span class="keyword">const</span> newFiber = &#123;</span><br><span class="line">      <span class="attr">type</span>: element.<span class="property">type</span>,</span><br><span class="line">      <span class="attr">props</span>: element.<span class="property">props</span>,</span><br><span class="line">      <span class="attr">parent</span>: fiber,</span><br><span class="line">      <span class="attr">dom</span>: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.构建fiber树</span></span><br><span class="line">    <span class="comment">// 将第一个子fiber赋值给父fiber的child属性</span></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.<span class="property">child</span> = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将后续子fiber赋值给前一个子fiber的sibling属性</span></span><br><span class="line">      prevSibling.<span class="property">sibling</span> = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prevSibling = newFiber;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.返回下一个工作单元</span></span><br><span class="line">  <span class="comment">// 如果当前节点存在子节点，则返回子节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.<span class="property">child</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.<span class="property">child</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不存在子节点，则返回兄弟节点，</span></span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber;</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFiber.<span class="property">sibling</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextFiber.<span class="property">sibling</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不存在兄弟节点，则返回父节点的兄弟节点</span></span><br><span class="line">    nextFiber = nextFiber.<span class="property">parent</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 函数执行完毕，会回到根节点，整个fiber树构建完成，此时函数返回为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是perfromUnitOfWork函数的实现。但是该函数有一个问题，他会一边构建Fiber树，一边频繁的操作DOM：<code>fiber.parent.dom.appendChild(fiber.dom)</code>，更高效的方式是先构建DOM树，最后再将整个树挂载到容器元素上。而且由于performUnitOfWork函数是在requestIdleCallback中执行的，这意味着他只会在浏览器空闲的时候执行，当有有用户操作时构建DOM的过程会被中断，这样会导致用户看到不完整的DOM树。所以我们需要将构建DOM树和挂载DOM树过程分开。这就是<strong>Render阶段</strong>和<strong>Commit阶段</strong>。<br>首先删除performUnitOfWork函数中的DOM操作代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前fiber的dom添加到父节点中</span></span><br><span class="line"><span class="comment">// if (fiber.parent) &#123;</span></span><br><span class="line"><span class="comment">//   fiber.parent.dom.appendChild(fiber.dom);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>修改其他代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他代码省略...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增commitRoot函数，fiber树构建完成后，一次性挂载到容器元素上</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">commitRoot</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">element, container</span>) &#123;</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  nextUnitOfWork = wipRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>; <span class="comment">// 下一个工作单元</span></span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span>; <span class="comment">// 新增一个变量，保存根fiber节点，commit阶段会用到该变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoop</span>(<span class="params">deadline</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = <span class="title function_">performUnitOfWork</span>(nextUnitOfWork);</span><br><span class="line">    shouldYield = deadline.<span class="title function_">timeRemaining</span>() &lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// nextUnitOfWork为空，说明Fiber树构建已经完成，接下来进入commit阶段执行commitRoot函数</span></span><br><span class="line">  <span class="keyword">if</span> (!nextUnitOfWork &amp;&amp; wipRoot) &#123;</span><br><span class="line">    <span class="title function_">commitRoot</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">requestIdleCallback</span>(workLoop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">requestIdleCallback</span>(workLoop);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他代码省略...</span></span><br></pre></td></tr></table></figure>
<p>接下来实现commitRoot函数，它会连接Fiber对象上的dom节点，然后挂载到容器元素上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitRoot</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">commitWork</span>(wipRoot.<span class="property">child</span>);</span><br><span class="line">  wipRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">commitWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.<span class="property">parent</span>.<span class="property">dom</span>;</span><br><span class="line">  domParent.<span class="title function_">appendChild</span>(fiber.<span class="property">dom</span>);</span><br><span class="line">  <span class="title function_">commitWork</span>(fiber.<span class="property">child</span>);</span><br><span class="line">  <span class="title function_">commitWork</span>(fiber.<span class="property">sibling</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前我们已经实现了一个最小可运行版本的React库了，接下来我们看一下运行效果，修改入口文件index.js，然后执行npm run serve启动项目：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;./lib/react-slim&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hi, Fiber<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">render</span>(element, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>项目启动后，可以在浏览器中看到渲染的结果。</p>
<h2 id="Reconciliation算法"><a href="#Reconciliation算法" class="headerlink" title="Reconciliation算法"></a>Reconciliation算法</h2><p>目前为止，我们已经实现了一个简单的React，但是只能新增元素，当组件状态更新时，我们还需要更新或删除元素。这就是Reconciliation算法的作用，它是一个深度优先遍历算法，会比较新旧Fiber树，标记需要更新或删除的节点，然后在commit阶段真正更新或删除他们。</p>
<p>那要如何实现呢？首先组件更新时我们会在render函数中收到新的element元素，其次在commit阶段我们还需要一个变量currentRoot保存最新Fiber树的根节点，最后需要为每一个Fiber节点添加一个alternate属性，用来保存上一次的Fiber节点。修改代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他代码省略...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">commitRoot</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">commitWork</span>(wipRoot.<span class="property">child</span>);</span><br><span class="line">  <span class="comment">// commit阶段，将根节点保存到currentRoot，用来做下次diff比较</span></span><br><span class="line">  currentRoot = wipRoot;</span><br><span class="line">  wipRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">element, container</span>) &#123;</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 新增alternate属性保存上一次的fiber节点</span></span><br><span class="line">    <span class="attr">alternate</span>: currentRoot</span><br><span class="line">  &#125;;</span><br><span class="line">  nextUnitOfWork = wipRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增一个currentRoot，保存上次一commit的fiber树根节点</span></span><br><span class="line"><span class="keyword">let</span> currentRoot = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他代码省略...</span></span><br></pre></td></tr></table></figure>
<p>我们的performUnitOfWork函数只能创建节点，也需要修改一下，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他代码省略...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据fiber节点创建dom</span></span><br><span class="line">  <span class="keyword">if</span> (!fiber.<span class="property">dom</span>) &#123;</span><br><span class="line">    fiber.<span class="property">dom</span> = <span class="title function_">createDom</span>(fiber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> elements = fiber.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">  <span class="title function_">reconcileChildren</span>(fiber, elements);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回下一个工作单元</span></span><br><span class="line">  <span class="comment">// 如果当前节点存在子节点，则返回子节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.<span class="property">child</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.<span class="property">child</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不存在子节点，则返回兄弟节点，</span></span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber;</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFiber.<span class="property">sibling</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextFiber.<span class="property">sibling</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不存在兄弟节点，则返回父节点的兄弟节点</span></span><br><span class="line">    nextFiber = nextFiber.<span class="property">parent</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 函数执行完毕，会回到根节点，整个fiber树构建完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的函数，用于协调子节点，将之前在performUnitOfWork中的大部分逻辑移到这里</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildren</span>(<span class="params">wipFiber, elements</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 获取当前节点的alternate属性的child属性,他会跟elements数组进行比较</span></span><br><span class="line">  <span class="keyword">let</span> oldFiber = wipFiber.<span class="property">alternate</span> &amp;&amp; wipFiber.<span class="property">alternate</span>.<span class="property">child</span>;</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.<span class="property">length</span> || oldFiber != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index];</span><br><span class="line">    <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断新旧节点的type是否相同</span></span><br><span class="line">    <span class="keyword">const</span> sameType = oldFiber &amp;&amp; element &amp;&amp; element.<span class="property">type</span> === oldFiber.<span class="property">type</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型相同，更新节点属性</span></span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        <span class="attr">type</span>: oldFiber.<span class="property">type</span>,</span><br><span class="line">        <span class="attr">props</span>: element.<span class="property">props</span>,</span><br><span class="line">        <span class="attr">dom</span>: oldFiber.<span class="property">dom</span>,</span><br><span class="line">        <span class="attr">parent</span>: wipFiber,</span><br><span class="line">        <span class="attr">alternate</span>: oldFiber,</span><br><span class="line">        <span class="attr">effectTag</span>: <span class="string">&quot;UPDATE&quot;</span> <span class="comment">// 新增effectTag属性，用于标记节点的操作类型，更新</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型不同，直接增加新节点。首次渲染时，只有新增操作</span></span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        <span class="attr">type</span>: element.<span class="property">type</span>,</span><br><span class="line">        <span class="attr">props</span>: element.<span class="property">props</span>,</span><br><span class="line">        <span class="attr">dom</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">parent</span>: wipFiber,</span><br><span class="line">        <span class="attr">alternate</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">effectTag</span>: <span class="string">&quot;PLACEMENT&quot;</span> <span class="comment">// 新增节点</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// element不存在，删除节点</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      oldFiber.<span class="property">effectTag</span> = <span class="string">&quot;DELETION&quot;</span>; <span class="comment">// 删除</span></span><br><span class="line">      deletions.<span class="title function_">push</span>(oldFiber); <span class="comment">// 新增deletions数组，用于存放删除节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个旧节点，用于下次循环比较</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber) &#123;</span><br><span class="line">      oldFiber = oldFiber.<span class="property">sibling</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将第一个子fiber赋值给父fiber的child属性</span></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      wipFiber.<span class="property">child</span> = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element) &#123;</span><br><span class="line">      <span class="comment">// 将后续子fiber赋值给前一个子fiber的sibling属性</span></span><br><span class="line">      prevSibling.<span class="property">sibling</span> = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prevSibling = newFiber;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> deletions = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">element, container</span>) &#123;</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">alternate</span>: currentRoot,</span><br><span class="line">  &#125;</span><br><span class="line">  deletions = []</span><br><span class="line">  nextUnitOfWork = wipRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他代码省略...</span></span><br></pre></td></tr></table></figure>
<p>接下来总结一下Reconciliation算法的实现：</p>
<ol>
<li>首先判断旧的Fiber节点和新的element元素类型是否相同，如果相同则只需要更新Fiber节点的属性props</li>
<li>如果类型不同，直接根据element元素创建新的Fiber节点</li>
<li>如果类型不同，element元素不存在，说明新的Fiber树不需要该节点了，此时将旧的Fiber节点标记为删除</li>
</ol>
<p>以上就是React Fiber架构能够在O(n)事件复杂度内完成Fiber树遍历的大致实现。需要声明的是，我们实现的Reconciliation算法只是一个简化版本，React的Reconciliation算法还有很多优化，如Diff算法、双缓存以及key的使用等等。</p>
<p>再下一步，修改commit阶段的代码，根据不同的effectTag属性，执行不同的操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 更新节点属性，待实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateDom</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">commitRoot</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 首先删除节点</span></span><br><span class="line">  deletions.<span class="title function_">forEach</span>(commitWork);</span><br><span class="line">  <span class="title function_">commitWork</span>(wipRoot.<span class="property">child</span>);</span><br><span class="line">  currentRoot = wipRoot;</span><br><span class="line">  wipRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">commitWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.<span class="property">parent</span>.<span class="property">dom</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.<span class="property">effectTag</span> === <span class="string">&quot;PLACEMENT&quot;</span> &amp;&amp; fiber.<span class="property">dom</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 新增节点</span></span><br><span class="line">    domParent.<span class="title function_">appendChild</span>(fiber.<span class="property">dom</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.<span class="property">effectTag</span> === <span class="string">&quot;UPDATE&quot;</span> &amp;&amp; fiber.<span class="property">dom</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新节点</span></span><br><span class="line">    <span class="title function_">updateDom</span>(fiber.<span class="property">dom</span>, fiber.<span class="property">alternate</span>.<span class="property">props</span>, fiber.<span class="property">props</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.<span class="property">effectTag</span> === <span class="string">&quot;DELETION&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    domParent.<span class="title function_">removeChild</span>(fiber.<span class="property">dom</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">commitWork</span>(fiber.<span class="property">child</span>);</span><br><span class="line">  <span class="title function_">commitWork</span>(fiber.<span class="property">sibling</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们实现最复杂的updateDom函数，用于更新节点属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其他代码省略...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createDom</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dom = </span><br><span class="line">    fiber.<span class="property">type</span> === <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">      ? <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : <span class="variable language_">document</span>.<span class="title function_">createElement</span>(fiber.<span class="property">type</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首次渲染时，也调用updateDom函数，用于设置属性和事件</span></span><br><span class="line">  <span class="title function_">updateDom</span>(dom, &#123;&#125;, fiber.<span class="property">props</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是事件属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isEvent</span> = (<span class="params">key</span>) =&gt; key.<span class="title function_">startsWith</span>(<span class="string">&#x27;on&#x27;</span>);</span><br><span class="line"><span class="comment">// 非children和事件属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isProperty</span> = (<span class="params">key</span>) =&gt; key !== <span class="string">&#x27;children&#x27;</span> &amp;&amp; !<span class="title function_">isEvent</span>(key);</span><br><span class="line"><span class="comment">// 判断是否是新属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isNew</span> = (<span class="params">prev, next</span>) =&gt; <span class="function">(<span class="params">key</span>) =&gt;</span> prev[key] !== next[key];</span><br><span class="line"><span class="comment">// 判断属性是否需要删除</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isGone</span> = (<span class="params">prev, next</span>) =&gt; <span class="function">(<span class="params">key</span>) =&gt;</span> !(key <span class="keyword">in</span> next);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateDom</span>(<span class="params">dom, prevProps, nextProps</span>) &#123;</span><br><span class="line">  <span class="comment">// 删除旧事件</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(prevProps)</span><br><span class="line">    .<span class="title function_">filter</span>(isEvent)</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> !(key <span class="keyword">in</span> nextProps) || <span class="title function_">isNew</span>(prevProps, nextProps)(key))</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eventType = name.<span class="title function_">toLowerCase</span>().<span class="title function_">substring</span>(<span class="number">2</span>);</span><br><span class="line">      dom.<span class="title function_">removeEventListener</span>(eventType, prevProps[name]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除旧属性</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(prevProps)</span><br><span class="line">    .<span class="title function_">filter</span>(isProperty)</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="title function_">isGone</span>(prevProps, nextProps))</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      dom[name] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置新属性</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(nextProps)</span><br><span class="line">    .<span class="title function_">filter</span>(isProperty)</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="title function_">isNew</span>(prevProps, nextProps))</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      dom[name] = nextProps[name];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加新事件</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(nextProps)</span><br><span class="line">    .<span class="title function_">filter</span>(isEvent)</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="title function_">isNew</span>(prevProps, nextProps))</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eventType = name.<span class="title function_">toLowerCase</span>().<span class="title function_">substring</span>(<span class="number">2</span>);</span><br><span class="line">      dom.<span class="title function_">addEventListener</span>(eventType, nextProps[name]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他代码省略...</span></span><br></pre></td></tr></table></figure>
<p>此时我们可以在浏览器中看到渲染的结果，当组件状态更新时，会触发Reconciliation算法更新或删除节点。我们修改index.js文件测试组件状态更新的功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;./lib/react-slim&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="title function_">render</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Hello, &#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123; count % 2 === 0 ? &#x27;Even&#x27; : &#x27;Odd&#x27; &#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123; count % 2 === 0 ? <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> : null &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">render</span>(element, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>();</span><br></pre></td></tr></table></figure>
<p>点击h1元素，可以看到count会递增，同时h2元素的文本会更新，ul元素会根据count的奇偶性显示或隐藏第三个li元素。</p>
<h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><p>上面在演示demo时，我们创建了一个element元素，但是实际开发中，我们会创建一个函数式组件，然后在render函数中调用该组件。基本形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">&#123;count&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Hello, &#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123; count % 2 === 0 ? &#x27;Even&#x27; : &#x27;Odd&#x27; &#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123; count % 2 === 0 ? <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> : null &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">count</span>=<span class="string">&#123;1&#125;</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>所以我们要实现函数式组件，首先修改performUnitOfWork函数，判断当前节点是否是函数式组件。</p>
<ol>
<li>如果是函数式组件，则调用该函数将返回的element元素添加到fiber节点的children属性中</li>
<li>如果是普通元素，则继续执行原来的逻辑</li>
<li>其余逻辑保持不变</li>
</ol>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> isFunctionComponent = fiber.<span class="property">type</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>;</span><br><span class="line">  <span class="keyword">if</span> (isFunctionComponent) &#123;</span><br><span class="line">    <span class="comment">// 如果是函数式组件，调用该函数，获取element元素</span></span><br><span class="line">    <span class="title function_">updateFunctionComponent</span>(fiber);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是普通元素，继续执行原来的逻辑</span></span><br><span class="line">    <span class="title function_">updateHostComponent</span>(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回下一个工作单元</span></span><br><span class="line">  <span class="comment">// 如果当前节点存在子节点，则返回子节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.<span class="property">child</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.<span class="property">child</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不存在子节点，则返回兄弟节点，</span></span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber;</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextFiber.<span class="property">sibling</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextFiber.<span class="property">sibling</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不存在兄弟节点，则返回父节点的兄弟节点</span></span><br><span class="line">    nextFiber = nextFiber.<span class="property">parent</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 函数执行完毕，会回到根节点，整个fiber树构建完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateFunctionComponent</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="comment">// 调用函数组件，将函数的返回值作为children</span></span><br><span class="line">  <span class="keyword">const</span> children = [fiber.<span class="title function_">type</span>(fiber.<span class="property">props</span>)];</span><br><span class="line">  <span class="title function_">reconcileChildren</span>(fiber, children);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通元素，创建dom节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateHostComponent</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.<span class="property">dom</span>) &#123;</span><br><span class="line">    fiber.<span class="property">dom</span> = <span class="title function_">createDom</span>(fiber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 协调子节点</span></span><br><span class="line">  <span class="title function_">reconcileChildren</span>(fiber, fiber.<span class="property">props</span>.<span class="property">children</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来修改commit阶段的代码，因为函数式组件的Fiber节点没有dom属性，所以修改commitWork函数中更新和删除节点的逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitWork</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// const domParent = fiber.parent.dom;</span></span><br><span class="line">  <span class="comment">// 替换成如下代码：</span></span><br><span class="line">  <span class="keyword">let</span> domParentFiber = fiber.<span class="property">parent</span>;</span><br><span class="line">  <span class="comment">// 函数式组件的dom属性不存在时，需要向上查找父节点的dom属性，直到找到dom属性</span></span><br><span class="line">  <span class="keyword">while</span> (!domParentFiber.<span class="property">dom</span>) &#123;</span><br><span class="line">    domParentFiber = domParentFiber.<span class="property">parent</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = domParentFiber.<span class="property">dom</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.<span class="property">effectTag</span> === <span class="string">&quot;PLACEMENT&quot;</span> &amp;&amp; fiber.<span class="property">dom</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 新增节点</span></span><br><span class="line">    domParent.<span class="title function_">appendChild</span>(fiber.<span class="property">dom</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.<span class="property">effectTag</span> === <span class="string">&quot;UPDATE&quot;</span> &amp;&amp; fiber.<span class="property">dom</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新节点</span></span><br><span class="line">    <span class="title function_">updateDom</span>(fiber.<span class="property">dom</span>, fiber.<span class="property">alternate</span>.<span class="property">props</span>, fiber.<span class="property">props</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.<span class="property">effectTag</span> === <span class="string">&quot;DELETION&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="comment">// 新增commitDeletion函数，用于删除节点</span></span><br><span class="line">    <span class="title function_">commitDeletion</span>(fiber, domParent); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">commitWork</span>(fiber.<span class="property">child</span>);</span><br><span class="line">  <span class="title function_">commitWork</span>(fiber.<span class="property">sibling</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">commitDeletion</span>(<span class="params">fiber, domParent</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果元素存在dom属性，说明普通元素，直接删除</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.<span class="property">dom</span>) &#123;</span><br><span class="line">    domParent.<span class="title function_">removeChild</span>(fiber.<span class="property">dom</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是函数式组件，递归查找子节点的dom属性，直到找到dom属性，再删除</span></span><br><span class="line">    <span class="title function_">commitDeletion</span>(fiber.<span class="property">child</span>, domParent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次修改index.js测试函数式组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;./lib/react-slim&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">&#123;count&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123; count % 2 === 0 ? &#x27;Even&#x27; : &#x27;Odd&#x27; &#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123; count % 2 === 0 ? <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> : null &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">count</span>=<span class="string">&#123;1&#125;</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>经过上面的修改，函数式组件的功能就完成了，但是目前组件还只能接受props，不能使用state，接下来我们实现useState函数。</p>
<h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p>新增函数useState，用于实现函数式组件的状态管理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数组件中处理hooks</span></span><br><span class="line"><span class="keyword">let</span> wipFiber = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 当前组件中的hook索引</span></span><br><span class="line"><span class="keyword">let</span> hookIndex = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateFunctionComponent</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  wipFiber = fiber;</span><br><span class="line">  hookIndex = <span class="number">0</span>;</span><br><span class="line">  wipFiber.<span class="property">hooks</span> = [];</span><br><span class="line">  <span class="comment">// 调用函数组件，将函数的返回值作为children</span></span><br><span class="line">  <span class="keyword">const</span> children = [fiber.<span class="title function_">type</span>(fiber.<span class="property">props</span>)];</span><br><span class="line">  <span class="title function_">reconcileChildren</span>(fiber, children);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">initial</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取旧的hook</span></span><br><span class="line">  <span class="keyword">const</span> oldHook = wipFiber.<span class="property">alternate</span> &amp;&amp; wipFiber.<span class="property">alternate</span>.<span class="property">hooks</span> &amp;&amp; wipFiber.<span class="property">alternate</span>.<span class="property">hooks</span>[hookIndex];</span><br><span class="line">  <span class="keyword">const</span> hook = &#123;</span><br><span class="line">    <span class="attr">state</span>: oldHook ? oldHook.<span class="property">state</span> : initial,</span><br><span class="line">    <span class="attr">queue</span>: []</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行setState时，将action添加到queue中，计算新的state</span></span><br><span class="line">  <span class="keyword">const</span> actions = oldHook ? oldHook.<span class="property">queue</span> : [];</span><br><span class="line">  actions.<span class="title function_">forEach</span>(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isFunction = action <span class="keyword">instanceof</span> <span class="title class_">Function</span>;</span><br><span class="line">    <span class="comment">// 如果是函数，执行函数，否则直接赋值</span></span><br><span class="line">    hook.<span class="property">state</span> = isFunction ? <span class="title function_">action</span>(hook.<span class="property">state</span>) : action;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">setState</span> = action =&gt; &#123;</span><br><span class="line">    hook.<span class="property">queue</span>.<span class="title function_">push</span>(action);</span><br><span class="line">    <span class="comment">// 触发workLoop中的更新流程</span></span><br><span class="line">    wipRoot = &#123;</span><br><span class="line">      <span class="attr">dom</span>: currentRoot.<span class="property">dom</span>,</span><br><span class="line">      <span class="attr">props</span>: currentRoot.<span class="property">props</span>,</span><br><span class="line">      <span class="attr">alternate</span>: currentRoot</span><br><span class="line">    &#125;;</span><br><span class="line">    nextUnitOfWork = wipRoot;</span><br><span class="line">    deletions = [];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  wipFiber.<span class="property">hooks</span>.<span class="title function_">push</span>(hook);</span><br><span class="line">  hookIndex++;</span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">state</span>, setState];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来修改index.js文件，测试useState函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;./lib/react-slim&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Hello, &#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123; count % 2 === 0 ? &#x27;Even&#x27; : &#x27;Odd&#x27; &#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123; count % 2 === 0 ? <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> : null &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">count</span>=<span class="string">&#123;1&#125;</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上代码我们就完成了mini版的React（完整代码<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/neilning-xc/react-slim">点击这里</a>），实现了React的核心功能，包括函数式组件、并发模式、Fiber架构、Reconciliation算法、Hooks。通过实现mini版React，我们可以更好的理解React的基本原理，为阅读React源码打下基础。当然，mini版React还有很多功能没有实现，如Context、useEffect、合成事件等，这些功能可以通过阅读React源码来实现。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://pomb.us/build-your-own-react/">https://pomb.us/build-your-own-react/</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://webdeveloper.beehiiv.com/p/build-react-400-lines-code">https://webdeveloper.beehiiv.com/p/build-react-400-lines-code</a></li>
</ol>


                

                <ul class="pager">
                    
                        <li class="previous"><a href="/学习/常见加密算法及其使用.html">&larr;  上一篇</a></li>
                    
                    
                        <li class="next"><a href="/学习/React流式渲染原理.html">下一篇 &rarr;</a></li>
                    
                </ul>
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>


    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/neilning-xc" rel="external nofollow noreferrer" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    
                        <li>
                            <a href="mailto:ningcoder@foxmail.com" rel="external nofollow noreferrer" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-envelope-o fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2025 Neil Ning<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/" rel="external nofollow noreferrer">Clean Blog</a> from <a href="http://startbootstrap.com/" rel="external nofollow noreferrer" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/" rel="external nofollow noreferrer">Hexo</a> by <a href="http://www.codeblocq.com/" rel="external nofollow noreferrer" target="_blank">Jonathan Klughertz</a></p>
                <!-- <p class="copyright text-muted"><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.miitbeian.gov.cn/">豫ICP备19003046号</a></p> -->
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//lib.baomitu.com/jquery/2.1.4/jquery.min.js"></script>

<!-- Bootstrap -->
<script src="//lib.baomitu.com/twitter-bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//lib.baomitu.com/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>