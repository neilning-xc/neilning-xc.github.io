<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="Tell the world with code"/>
    

    <!--Author-->
    
        <meta name="author" content="Neil Ning"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="渐进式Web应用(PWA)实战篇之Workbox"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="Tell the world with code"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Neil的博客"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="https://neilning-xc.github.io/img/banner.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="https://neilning-xc.github.io/img/banner.jpg"/>
    

    <!-- Title -->
    
    <title>渐进式Web应用(PWA)实战篇之Workbox - Neil的博客</title>

    <!-- Bootstrap Core CSS -->
    <link href="//lib.baomitu.com/twitter-bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//lib.baomitu.com/featherlight/1.3.5/featherlight.min.css" rel="stylesheet"/>

    <!-- Google Analytics -->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPEMLKFYYW"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-ZPEMLKFYYW');
    </script>



    <!-- favicon -->
    

<meta name="generator" content="Hexo 5.4.2"></head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Neil的博客</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                首页
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                归档
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                标签
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                分类
                            
                        </a>
                    </li>
                
                    <li>
                        <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/neilning-xc/neilning-xc.github.io">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header post-header" style="background-image: url('渐进式Web应用-PWA-实战篇之Workbox/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>渐进式Web应用(PWA)实战篇之Workbox</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2020-11-30
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/PWA/">#PWA</a> <a href="/tags/Service-Worker/">#Service Worker</a> <a href="/tags/Workbox/">#Workbox</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/学习/">学习</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p>前一篇文章讲了PWA应用的理论基础Service Worker，本篇文章讲解PWA如何应用在实际前端项目中，如果你在阅读本文之前还没有阅读第一篇文章<a target="_blank" rel="noopener external nofollow noreferrer" href="https://gitlab.aihaisi.com/qiexr/docs/-/issues/809">渐进式Web应用(PWA)理论篇之Service Worker</a>，强烈建议你先去阅读并理解里面的一些概念，然后再回来阅读本文。<br>上一篇文章在讲解Service Worker生命周期的示例代码中，所有要缓存的文件路径的列表，都是我们手写的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const CACHE_NAME = &#x27;v1&#x27;;</span><br><span class="line">const CACHE_FILES = [</span><br><span class="line">    &#x27;/cat.jpg&#x27;,</span><br><span class="line">    &#x27;/app.css&#x27;,</span><br><span class="line">    &#x27;/app.js&#x27;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">self.addEventListener(&#x27;install&#x27;, function(event) &#123;</span><br><span class="line">    event.waitUntil(</span><br><span class="line">        caches.open(CACHE_NAME).then(function (cache) &#123;</span><br><span class="line">            return cache.addAll(CACHE_FILES);</span><br><span class="line">        &#125;).then(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;cache added&#x27;);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>而现在的前端项目都是工程化的，需要Webpack这样的打包工具进行处理，为了在生产环境利用浏览器的<strong>长缓存</strong>，生成的文件名都有带Hash值，即文件名称是不固定的，所以在实际项目中这样靠手动维护要缓存的文件路径列表是不可行。那有没有一种工具能和Webpack等现在比较流行的打包工具集成在一起，通过自动化的方式生成要缓存的文件列表呢？这就是这篇文章要重点介绍的工具——<a target="_blank" rel="noopener external nofollow noreferrer" href="https://developers.google.com/web/tools/workbox">Workbox</a>。</p>
<h2 id="Workbox简介"><a href="#Workbox简介" class="headerlink" title="Workbox简介"></a>Workbox简介</h2><p>Workbox是由谷歌团队推出的一款优秀的Service Worker实战工具库集合，功能强大，并且包含专门的Gulp和Webpack插件。这使得Workbox能很轻松的和现有的打包工具进行整合。</p>
<p>如果你已经对Service Worker有所研究，可能你也听说过sw-precache和sw-toolbox这两个库，他们也是由谷歌团队推出的，但是后来谷歌的工程师认为Workbox才是处理PWA应用的统一的解决方案，所以停止了对这两个库的维护。</p>
<h2 id="初始化一个Webpack项目"><a href="#初始化一个Webpack项目" class="headerlink" title="初始化一个Webpack项目"></a>初始化一个Webpack项目</h2><p>本文通过一个典型的React项目来演示如何将Webpack和Workbox整合在一起，最终实现一个启用了Service Worker缓存功能的PWA应用。首先需要创建一个SPA项目，打包工具使用Webpack，项目采用ReactJS，antd框架，使用loadable实现按需加载。在项目根目录运行<code>npm run build</code>即可将项目打包。引入Workbox之前，项目使用浏览器强缓存，缓存JS，CSS，图片等静态资源文件。然后我们使用Workbox，通过不同的方式演示如何将现有项目改造成PWA。源码可以点击<a target="_blank" rel="noopener external nofollow noreferrer" href="https://codesandbox.io/s/sw-webpack-0jblj">这里</a></p>
<p>这里模拟一个博客网站，首页有四个文章的卡片，文章卡片显示文章的封面图，作者，标题等信息。点击文章卡片可以进入文章详情页，文章详情页显示文章标题，作者头像，文章图片等信息。文章将一步步演示如何对前端的资源文件进行预缓存和运行时缓存。<br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image1.png" alt="image"><br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image2.png" alt="image"></p>
<h2 id="自动生成Service-Worker文件"><a href="#自动生成Service-Worker文件" class="headerlink" title="自动生成Service Worker文件"></a>自动生成Service Worker文件</h2><h3 id="配置Webpack"><a href="#配置Webpack" class="headerlink" title="配置Webpack"></a>配置Webpack</h3><p>一个典型的PWA项目，一定包含一个Service Worker文件，Workbox功能强大，如果你不想过多的关注Service Worker缓存细节，你完全可以让Workbox帮我们生成一份Service Worker文件，只需要对Webpack的配置文件做简单的改造即可做到这一点，首先安装Workbox的Webpack插件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install workbox-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>

<p>接下来修改Webpack配置文件（<code>build-config/webpack.prod.js</code>）的plugins选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const WorkboxPlugin = require(&#x27;workbox-webpack-plugin&#x27;);</span><br><span class="line"></span><br><span class="line">// ...省略其他配置代码</span><br><span class="line">plugins: [</span><br><span class="line">    // 其他plugins代码...</span><br><span class="line">    new WorkboxPlugin.GenerateSW(&#123;</span><br><span class="line">        swDest: &#x27;service-worker.js&#x27;,</span><br><span class="line">        clientsClaim: true,</span><br><span class="line">        skipWaiting: true,</span><br><span class="line">        maximumFileSizeToCacheInBytes: 23*1024*1024</span><br><span class="line">    &#125;)</span><br><span class="line">]   </span><br></pre></td></tr></table></figure>

<p>可以看到只通过几行代码，我们便可以让Workbox帮我们生成Service Worker文件，不过需要注意的是，由于WorkboxPlugin.GenerateSW需要根据Webpack生成的静态资源文件来生成ServiceWorker文件，所以必须将该插件放到plugins数组的最后。<br>代码中，我们引入刚刚安装的<code>workbox-webpack-plugin</code>，通过调用WorkboxPlugin.GenerateSW函数即可生成Service Worker文件，该函数中的各个配置项的含义如下：</p>
<ul>
<li><code>swDest</code>为Workbox指定要生成的Service Worker文件名称。</li>
<li><code>clientsClaim</code>选项告诉ServiceWorker在激活（<code>activated</code>）之后立即接管整个应用，其具体含义可以参考我的第一篇文章<a target="_blank" rel="noopener external nofollow noreferrer" href="https://gitlab.aihaisi.com/qiexr/docs/-/issues/809">PWA应用之理论篇</a>。</li>
<li><code>skipWaiting</code>指定ServiceWorker在更新之后跳过等待阶段（<code>waiting</code>）直接进入<code>activataed</code>阶段，详情参考<a target="_blank" rel="noopener external nofollow noreferrer" href="https://gitlab.aihaisi.com/qiexr/docs/-/issues/809">PWA应用之理论篇</a>。</li>
<li><code>maximumFileSizeToCacheInBytes</code>选项是为了解决打包后生成的文件体积过大的问题。</li>
</ul>
<p>有关WorkboxPlugin.GenerateSW函数其他更加详细的配置项及含义，可以参考<a target="_blank" rel="noopener external nofollow noreferrer" href="https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-webpack-plugin.GenerateSW">这里</a>。</p>
<h3 id="注册Service-Worker"><a href="#注册Service-Worker" class="headerlink" title="注册Service Worker"></a>注册Service Worker</h3><p>改造完Webpack的配置文件之后，我们需要让页面注册生成的Service Worker文件，如第一篇文章所讲的，注册Service Worker的工作是在页面主线程中完成的，所以在index.html文件的body标签结束之前加入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    if (&#x27;serviceWorker&#x27; in navigator) &#123;        </span><br><span class="line">        window.addEventListener(&#x27;load&#x27;, () =&gt; &#123;</span><br><span class="line">            navigator.serviceWorker.register(&#x27;/service-worker.js&#x27;).then(registration =&gt; &#123;</span><br><span class="line">                console.log(&#x27;SW registered: &#x27;, registration);</span><br><span class="line">            &#125;).catch(registrationError =&gt; &#123;</span><br><span class="line">                console.log(&#x27;SW registration failed: &#x27;, registrationError);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="浏览器中查看ServiceWorker"><a href="#浏览器中查看ServiceWorker" class="headerlink" title="浏览器中查看ServiceWorker"></a>浏览器中查看ServiceWorker</h3><p>配置完之后，运行<code>npm run build</code>，打开dist目录，即可看到Worbox为我们生成的service-worker.js文件。在项目根目录执行<code>http-server -p 5000 ./dist</code>启动一个Web服务器，然后在浏览中访问<code>http://localhost:5000</code>，打开浏览器控制台即可查看生成Service Worker文件和缓存。<br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image3.png" alt="image"><br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image4.png" alt="image"></p>
<p>由于是首次打开页面，Service Worker会预缓存所有的文件，即页面加载渲染完之后会再去服务器请求所有的资源文件，来预缓存他们，应用打开Network面板：<br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image5.png" alt="image"></p>
<p>点击文章卡片进入新的页面，或者刷新当前页面，可以在控制台中看到页面从Service Worker加载静态资源文件，证明我们预缓存的文件已经开始生效：<br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image6.png" alt="image"></p>
<h3 id="运行时缓存"><a href="#运行时缓存" class="headerlink" title="运行时缓存"></a>运行时缓存</h3><p>目前，我们已经能把所有的静态资源文件都已经预缓存到Service Worker中，但是还有某些资源请求如文章的数据接口是在应用运行时发起的，Workbox并没有把这部分请求返回的缓存在Service Worker中。例如我们将应用设置为离线模式，设置方式如下：<br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image7.png" alt="image"></p>
<p>设置为离线之后，刷新页面可以看到文章列表为空，查看控制台可以看到文章的列表接口调用发生错误：<br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image8.png" alt="image"></p>
<p>为了添加运行时缓存，我们需要修改Webpack的配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new WorkboxPlugin.GenerateSW(&#123;</span><br><span class="line">    swDest: &#x27;service-worker.js&#x27;,</span><br><span class="line">    clientsClaim: true,</span><br><span class="line">    skipWaiting: true,</span><br><span class="line">    maximumFileSizeToCacheInBytes: 23*1024*1024,</span><br><span class="line">    runtimeCaching: [&#123;</span><br><span class="line">        urlPattern: /.*hacker-news\.firebaseio\.com\/.*/,</span><br><span class="line">        handler: &#x27;StaleWhileRevalidate&#x27;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们新增加了<code>runtimeCaching</code>配置项，其中<code>urlPattern</code>是一个正则表达式，匹配我们要缓存的请求路径（为了演示，我们调用第三方的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/HackerNews/API">hacker-news</a>的开放接口，这里也说明Service Worker能够缓存跨域的数据），<code>handler</code>指定缓存策略，后面会介绍其具体含义。</p>
<p>修改完配置文件后，再次执行<code>npm run build</code>，然后取消离线模式，刷新页面、点击某个文章卡片可以正常看页面显示，接着再次将应用设置为离线模式，并刷新页面，可以看到页面依然正常显示，查看控制台也能看到文章接口的数据也来自于Service Worker。</p>
<h2 id="创建自己的Service-Worker"><a href="#创建自己的Service-Worker" class="headerlink" title="创建自己的Service Worker"></a>创建自己的Service Worker</h2><p>前面我们利用Workbox的Webpack插件，通过简单的配置很方便的生成了service-worker.js文件，但是这种方式只适合小型简单项目。如果你的项目比较复杂，并且如果你想控制不同资源的缓存策略，或者你想使用诸如<code>Push notification</code>等其他Service Worker的特性，就必须自定义生成的service-worker.js文件。接下来演示如何自定Service Worker文件。</p>
<h3 id="配置Webpack-1"><a href="#配置Webpack-1" class="headerlink" title="配置Webpack"></a>配置Webpack</h3><p>首先将Webpack中自动生成service-worker.js的代码修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ...省略其他配置代码</span><br><span class="line">plugins: [   </span><br><span class="line">    // 其他plugins代码...</span><br><span class="line">    new WorkboxPlugin.InjectManifest(&#123;</span><br><span class="line">        swSrc: path.resolve(__dirname, &#x27;../sw.js&#x27;),</span><br><span class="line">        swDest: &#x27;service-worker.js&#x27;,</span><br><span class="line">        exclude: [/images\/(a\d)\.jpeg/]</span><br><span class="line">    &#125;)</span><br><span class="line">]   </span><br></pre></td></tr></table></figure>
<p>代码跟之前的区别就是使用WorkboxPlugin.InjectManifest，其中<code>swSrc</code>选项，该选项指定自定义的Service Worker模版文件的路径，<code>exclude</code>选项指定不需要预缓存的文件路径，这里我们指定文章作者的头像，即我们不预缓存文章作者的头像。</p>
<h3 id="配置自定义Service-Worker选项"><a href="#配置自定义Service-Worker选项" class="headerlink" title="配置自定义Service Worker选项"></a>配置自定义Service Worker选项</h3><p>首先安装Workbox相关的包，<code>npm install workbox-routing workbox-precaching workbox-strategies workbox-core —-save-dev</code>，安装成功后在项目根目录下创建文件sw.js，即上文中swSrc配置项，其完整代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import &#123;precacheAndRoute&#125; from &#x27;workbox-precaching&#x27;;</span><br><span class="line">import &#123;registerRoute&#125; from &#x27;workbox-routing&#x27;;</span><br><span class="line">import &#123;CacheFirst, NetworkFirst, StaleWhileRevalidate&#125; from &#x27;workbox-strategies&#x27;;</span><br><span class="line">import &#123;ExpirationPlugin&#125; from &#x27;workbox-expiration&#x27;;</span><br><span class="line">import &#123;skipWaiting, clientsClaim&#125; from &#x27;workbox-core&#x27;;</span><br><span class="line"></span><br><span class="line">skipWaiting();</span><br><span class="line">clientsClaim();</span><br><span class="line"></span><br><span class="line">// CSS文件和JS文件都带有版本号，因此可以使用CacheFirst策略。</span><br><span class="line">registerRoute(</span><br><span class="line">    (&#123;request&#125;) =&gt; request.destination === &#x27;script&#x27;,</span><br><span class="line">    new CacheFirst(&#123;</span><br><span class="line">        cacheName: &#x27;js-cache&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">registerRoute(</span><br><span class="line">    (&#123;request&#125;) =&gt; request.destination === &#x27;style&#x27;,</span><br><span class="line">    new CacheFirst(&#123;</span><br><span class="line">        cacheName: &#x27;css-cache&#x27;,</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 文章图片不经常更新，也可以采用缓存优先的策略</span><br><span class="line">registerRoute(</span><br><span class="line">    /\/images\/(p.*)\.(?:png|gif|jpg|jpeg)/,</span><br><span class="line">    new CacheFirst(&#123;</span><br><span class="line">        cacheName: &#x27;images-cache&#x27;,</span><br><span class="line">        plugins: [</span><br><span class="line">            new ExpirationPlugin(&#123;</span><br><span class="line">                // Cache only 20 images.</span><br><span class="line">                maxEntries: 20,</span><br><span class="line">                // Cache for a maximum of a week.</span><br><span class="line">                maxAgeSeconds: 7 * 24 * 60 * 60,</span><br><span class="line">            &#125;)</span><br><span class="line">        ],</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 用户图像缓存策略采用StaleWhileRevalidate, 即优先使用缓存，再向服务器发起请获取最新数据</span><br><span class="line">registerRoute(</span><br><span class="line">    /\/images\/(a.*)\.(?:png|gif|jpg|jpeg)/,</span><br><span class="line">    new StaleWhileRevalidate(&#123;</span><br><span class="line">        cacheName: &#x27;avators-cache&#x27;,</span><br><span class="line">        plugins: [</span><br><span class="line">            new ExpirationPlugin(&#123;</span><br><span class="line">                // Cache only 20 images.</span><br><span class="line">                maxEntries: 20,</span><br><span class="line">                // Cache for a maximum of a week.</span><br><span class="line">                maxAgeSeconds: 7 * 24 * 60 * 60,</span><br><span class="line">            &#125;)</span><br><span class="line">        ],</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 测试时候发现，改行代码必须放在最后，官方文档没有明确解释原因</span><br><span class="line">precacheAndRoute(self.__WB_MANIFEST);</span><br></pre></td></tr></table></figure>
<p>可以看到代码中出现了很多新的配置项，我们来一一解释一下：</p>
<ul>
<li>precacheAndRoute(self.__WB_MANIFEST)，它就像一个占位符，最终该代码会被生成的带Hash的文件列表替换掉。</li>
<li>registerRoute，该函数接受两个参数，第一个参数是文件的类型，或者文件路径的正则表达式。第二个参数是需要接收缓存策略对象。</li>
<li>缓存策略的构造函数接收一个对象，在该对象中，<code>cacheName</code>指定缓存的名称，<code>plugins</code>指定Workbox内置的缓存插件。</li>
</ul>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>上文中提到了缓存策略，在离线应用中缓存策略是一个非常重要的概念，他主要解决Service Worker匹配到缓存路径时，如何获取内容。想象一下，SW匹配到某个图片文件路径，此时开发者可能想优先从SW缓存中获取图片数据，如果缓存不存在，才向服务器发起网络请求，然后将请求后的数据，放入SW缓存以供下次使用。或者开发想优先向服务器发起网络请求，当网络没有问题请求成功时，可以得到最新数据，如果发生断网，网络请求失败时，期望应用去读取缓存，使用这种兜底策略来获取数据。又或者针对某些资源，开发者希望永远向服务器发起网络请求，如果网络出现故障，直接报错。<br>可以看到，以上的这些场景都是合理的，所以为了支持这些常见的缓存策略场景，也为了避免开发者重复的实现这些缓存策略，Workbox内置了以下五种常见的缓存策略。下面做一个简单的总结，更详细的解释、实现方式、适用场景等点击<a target="_blank" rel="noopener external nofollow noreferrer" href="https://web.dev/offline-cookbook/">这里</a>。</p>
<ul>
<li><p>Network First<br>  该策略会优先从网络获取数据，如果成功，则返回数据，并将数据保存到缓存中，如果不成功，则读取最近一次的缓存数据。此模式适用于更新频繁，且不带有”版本“的数据，比如文章列表，它只是为网络请求失败提供一种兜底策略。<br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image9.png" alt="image"></p>
</li>
<li><p>Cache First<br>  该策略会优先从缓存获取数据，如果缓存存在，则优先读取缓存，不发起网络请求。如果缓存不存在，则发起网络请求，并将响应成功的数据保存在缓存中，以便下次直接从缓存中获取数据。此模式适合于带有版本的静态资源文件，如app.sadf798h.css，main.safd798jh.js。即使发起网络请求，也可以利用浏览器自身的强缓存策略保证性能。<br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image10.png" alt="image"></p>
</li>
<li><p>Stale While Revalidate：<br>  该策略的含义是，对于某个请求，优先使用缓存，如果缓存存在，则读取缓存，并且SW会在后台发起网络请求，如果成功则自动更新缓存。如果缓存不存在，则发起网络请求，直到获取数据，然后更新缓存，该策略总是会发起网络请求。比如用户头像，可能经常更新，但不是每次都必须加载最新版本。<br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image11.png" alt="image"></p>
</li>
<li><p>Network Only<br>  该策略强制只能发起网络请求获取数据。<br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image12.png" alt="network-only"></p>
</li>
<li><p>Cache Only<br>  该策略只会从缓存中读取数据，这种模式适合搭配Workbox的插件，如后台同步插件，定时在后台更新要缓存的数据。<br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image13.png" alt="cache-only"></p>
</li>
</ul>
<blockquote>
<p>以上图片来自于<a target="_blank" rel="noopener external nofollow noreferrer" href="https://developers.google.com/web/tools/workbox/modules/workbox-strategies">Google的文档</a>    </p>
</blockquote>
<p>如果你有兴趣，<a target="_blank" rel="noopener external nofollow noreferrer" href="https://developers.google.com/web/tools/workbox/guides/using-plugins">点击这里</a>可以了解这些缓存策略的实现细节。</p>
<p>配置完成之后，再次运行<code>npm run build</code>，为了能够在浏览器中查看最新的缓存，我们需要删除之前的Service Worker缓存，点击<strong>Clear side data</strong>：<br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image14.png" alt="clear_cache"></p>
<p>刷新首页之后，可以看到我们在sw.js文件中定义的缓存：<br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image15.png" alt="image"></p>
<p>点击第一篇文章，打开文章详情页面，由于文章详情页面包含文章做的头像图片文件，所以新的<code>avators-cache</code>缓存会被加入到Cache Storage中。<br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image16.png" alt="image"></p>
<p>我们返回首页后，再次点击第一篇文章，即模拟用户第二次打开该页面，可以从控制台中看到资源文件已经从Service Worker中读取，并且由于<code>avators-cache</code>缓存的策略是<code>Stale While Revalidate</code>，浏览器会发起请求，获取最新的数据已更新缓存。<br><img src="/%E5%AD%A6%E4%B9%A0/%E6%B8%90%E8%BF%9B%E5%BC%8FWeb%E5%BA%94%E7%94%A8-PWA-%E5%AE%9E%E6%88%98%E7%AF%87%E4%B9%8BWorkbox/image17.png" alt="image"></p>
<p>至此，我们成功地通过自定义sw.js来定制不同类型文件的缓存策略。</p>
<h2 id="Create-React-App和Vue-CLI"><a href="#Create-React-App和Vue-CLI" class="headerlink" title="Create React App和Vue CLI"></a>Create React App和Vue CLI</h2><p>上面介绍了如何在Webpack中自定义Workbox的配置项，将两者整合起来实现PWA。如果你已经掌握了这部分内容，那么在Create React App和Vue CLI中使用Service Worker对你来说将会变得格外简单，因为这两个脚手架工具中的PWA功能，底层使用的都是Workbox，并且几乎不需要什么配置就可以启用SW。Create React App中有关Service Worker的文档可以<a target="_blank" rel="noopener external nofollow noreferrer" href="https://create-react-app.dev/docs/making-a-progressive-web-app">参考这里</a>，Vue CLI可以<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/vuejs/vue-docs-zh-cn/blob/master/vue-cli-plugin-pwa/README.md">参考这里</a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://developers.google.com/web/tools/workbox/guides/codelabs/webpack">https://developers.google.com/web/tools/workbox/guides/codelabs/webpack</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://web.dev/offline-cookbook">https://web.dev/offline-cookbook</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://developers.google.com/web/tools/workbox">https://developers.google.com/web/tools/workbox</a></li>
</ul>


                

                <ul class="pager">
                    
                        <li class="previous"><a href="/翻译/一个数据包的奇幻旅程（上）【译文】.html">&larr;  上一篇</a></li>
                    
                    
                        <li class="next"><a href="/学习/PWA理论篇之Service-Worker.html">下一篇 &rarr;</a></li>
                    
                </ul>
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>


    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/neilning-xc" rel="external nofollow noreferrer" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    
                        <li>
                            <a href="mailto:ningcoder@foxmail.com" rel="external nofollow noreferrer" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-envelope-o fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2025 Neil Ning<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/" rel="external nofollow noreferrer">Clean Blog</a> from <a href="http://startbootstrap.com/" rel="external nofollow noreferrer" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/" rel="external nofollow noreferrer">Hexo</a> by <a href="http://www.codeblocq.com/" rel="external nofollow noreferrer" target="_blank">Jonathan Klughertz</a></p>
                <!-- <p class="copyright text-muted"><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.miitbeian.gov.cn/">豫ICP备19003046号</a></p> -->
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//lib.baomitu.com/jquery/2.1.4/jquery.min.js"></script>

<!-- Bootstrap -->
<script src="//lib.baomitu.com/twitter-bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//lib.baomitu.com/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>