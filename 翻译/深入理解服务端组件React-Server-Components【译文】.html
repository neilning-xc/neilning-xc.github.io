<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="Tell the world with code"/>
    

    <!--Author-->
    
        <meta name="author" content="Neil Ning"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="深入理解服务端组件React Server Components【译文】"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="Tell the world with code"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Neil的博客"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="https://neilning-xc.github.io/img/banner.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="https://neilning-xc.github.io/img/banner.jpg"/>
    

    <!-- Title -->
    
    <title>深入理解服务端组件React Server Components【译文】 - Neil的博客</title>

    <!-- Bootstrap Core CSS -->
    <link href="//lib.baomitu.com/twitter-bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//lib.baomitu.com/featherlight/1.3.5/featherlight.min.css" rel="stylesheet"/>

    <!-- Google Analytics -->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPEMLKFYYW"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-ZPEMLKFYYW');
    </script>



    <!-- favicon -->
    

<meta name="generator" content="Hexo 5.4.2"></head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Neil的博客</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                首页
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                归档
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                标签
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                分类
                            
                        </a>
                    </li>
                
                    <li>
                        <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/neilning-xc/neilning-xc.github.io">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header post-header" style="background-image: url('深入理解服务端组件React-Server-Components【译文】/bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>深入理解服务端组件React Server Components【译文】</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                            Posted by Neil Ning on
                        
                        
                            2023-12-14
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/React/">#React</a> <a href="/tags/RSC/">#RSC</a> <a href="/tags/React-Server-Component/">#React Server Component</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/翻译/">翻译</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该文章翻译自【Making Sense of React Server Components】，<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.joshwcomeau.com/react/server-components/#introduction-to-react-server-components-3">点击这里</a>查看原文</p>
<p>今年是React的十周年生日，这让我感觉自己真的老了。<br>自从React首次被引入社区以来的十年时间里，它经历过几次演变。只要React团队发现某个问题有更好的解决方案，他们甚至会不惜做一些激进的改变。<br>几个月之前，React团队展示了React Server Components，这是一个全新的模式：一种只能在服务器上运行的React组件。<br>网络上有很多人对此感到困惑，许多人对此有很多疑问，它到底是什么？它是如何工作的？使用它有什么好处？它和服务端渲染有什么区别？<br>我做了很多关于React Server Components的实验，已经能够回答我心中的疑惑。我必须要承认，这比我想象中的还要令人兴奋，它真得很酷。<br>所以我今天的目标是深入浅出的解释React Server Components，希望能够回答你关于React Server Components的问题。</p>
<blockquote>
<h4 id="目标读者"><a href="#目标读者" class="headerlink" title="目标读者"></a>目标读者</h4><p>这篇教程主要是写给那些已经使用过React的开发者，并且对React Server Components感到好奇的读者。你不必是个React专家，不过如果你还是个初学者，你可能会对此感到十分困惑。</p>
</blockquote>
<h2 id="服务端渲染快速入门"><a href="#服务端渲染快速入门" class="headerlink" title="服务端渲染快速入门"></a>服务端渲染快速入门</h2><p>为了弄清楚RSC，首先需要了解服务端渲染（SSR）是如何工作的。如果你已经很熟悉SSR，你可以跳过这个章节。<br>2015年当我第一次使用React时，大多数React项目使用的是客户端渲染的策略。用户会接收到像下面这样的HTML文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;/static/js/bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><code>bundle.js</code>脚本包含了挂载和运行应用的一切代码，包括React、其他第三方依赖以及我们自己业务逻辑代码。<br>一旦JS脚本下载并解析完毕，React框架就会开始工作，渲染整个应用的DOM节点，并将它们挂载到空的<code>&lt;div id=&quot;root&quot;&gt;</code>中。<br>这种方式的主要问题在它需要花一些时间来完成JS文件下载、解析、执行的工作。在此期间，用户将会看到一个空白的屏幕。随着时间推移，更多的业务功能会被添加，JS bundle的体积会不越来越大，用户将等待更久的时间。<br>服务端渲染就是要改善这个问题的。SSR不再发送一个空的HTML文件，而是渲染整个应用生成完整的HTML，用户会接收到一份有完整的HTML文档。<br>这份HTML文件仍然包含<code>&lt;script&gt;</code>标签，因为我们仍然需要React在客户端运行来处理所有的交互行为。不过此时React在浏览器上的运行会稍有些不同，它不再从头生成所有节点，而是利用已经生成的HTML节点，这个过程就是我们熟知的水合。<br>我很喜欢React的核心开发人员Dan Abramov的解释：</p>
<blockquote>
<p>水合就像是向干瘪的HTML浇包含交互和事件处理的水。</p>
</blockquote>
<p>一旦JS文件完成下载，React将会快速运行整个应用，构建一个虚拟的UI，并将它和真实的DOM对应起来，附上事件处理函数，执行所有的副作用函数等等。<br>简单的说，SSR就是服务端生成初始的HTML，在下载和解析JS文件的时候，用户不必在等待白屏。客户端React会协调已经生成好的DOM节点，绑定交互事件。</p>
<blockquote>
<h4 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h4><p>当我们谈论SSR的时候，我们通常可以认为它会经历以下流程：</p>
<ol>
<li>用户访问myWebsite.com。</li>
<li>Node.js服务收到请求并立即渲染React应用，生成HTML。</li>
<li>将刚刚生成的HTML发送给客户端</li>
</ol>
<p>这是实现SSR的一种方式，但不是唯一的方式。另外一种方式是在构建应用的时候就生成好HTML。<br>通常情况下，React应用是需要编译的，将JSX转换成JavaScript，并打包所有的模块。如果我们为不同的路由提前生成好HTML呢？<br>这就是我们熟知的静态站点生成（SSG），这就是SSR的另外一种形式。<br>在我看来，术语SSR包括了多种不同的渲染策略，但他们都有一个共同点：初始的渲染发生在服务端，如Node.js运行时中。这个过程会利用<code>ReactDOMServer</code>API。生成的时机不重要，既可以在请求时生成，也可以在编译时生成，如论哪种方式，都属于SSR。</p>
</blockquote>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>接下来我们讨论下如何在React中获取数据。通常，我们会有两个应用通过网络进行通信：</p>
<ul>
<li>客户端的React应用</li>
<li>服务端的REST API</li>
</ul>
<p>利用React Query、SWR或者Apollo等第三方库，客户端向后端发起网络请求，后端从数据库中获取数据并将数据返回给前端。流程如下图所示：<br><img src="/%E7%BF%BB%E8%AF%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%84%E4%BB%B6React-Server-Components%E3%80%90%E8%AF%91%E6%96%87%E3%80%91/rsc1.png" alt="rsc1.png"></p>
<blockquote>
<h4 id="示例图解释"><a href="#示例图解释" class="headerlink" title="示例图解释"></a>示例图解释</h4><p>本文包含了多个网络请求流程图，这些图只是用来演示数据是如何在客户端和服务端之间流转的，包括不同的渲染策略之间的数据流转差异。<br>底部的数据不代表真实时间，这些数字的单位既不是秒也不分钟。现实的时间数字会受一系列因素的影响，有较大的差异。这些图只是为了帮你理解概念，并不表示任何真实的数据。</p>
</blockquote>
<p>上图展示了客户端渲染（CSR）的流程，首先客户端会接收到HTML文件，这个文件不包含任何内容，只有一个或多个<code>&lt;script&gt;</code>标签。<br>一旦JS完成下载并开始解析，我们的React应用就会启动，创建一系列DOM节点来渲染UI，然而初始时我们没有任何实际的数据，所以我们只能先利用骨架图渲染一个空壳，如头部、尾部和包含大致布局的骨架屏。<br>可能你经常能看到类似的模式，例如UberEats，页面先渲染出一个空壳，获取到数据之后再渲染出实际的餐厅数据。<br><img src="/%E7%BF%BB%E8%AF%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%84%E4%BB%B6React-Server-Components%E3%80%90%E8%AF%91%E6%96%87%E3%80%91/rsc2.png" alt="rsc2.png"></p>
<p>用户会先看到加载动画，直到获取数据的网络请求完成，React会重新渲染，将真实的内容替换掉加载动画。<br>让我们来看一下另外一种实现方式。下图的数据获取模式和上面的相同，但是是将CSR替换为SSR：<br><img src="/%E7%BF%BB%E8%AF%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%84%E4%BB%B6React-Server-Components%E3%80%90%E8%AF%91%E6%96%87%E3%80%91/rsc3.png" alt="rsc3.png"></p>
<p>在新的流程中，我们将第一次渲染放在服务器上执行。这意味着用户接收到的HTML不再是空的HTML。<br>该流程做了一点点优化，至少一个空壳的体验要比空白页面要好。但是这并不是什么显著的优化，用户访问我们的APP不是来看加载动画的，而是要看到实际的内容。（餐厅、酒店列表，搜索结果，信息等等）<br>为了真正理解用户体验的差异，我们给示意图加上性能指标。<br><img src="/%E7%BF%BB%E8%AF%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%84%E4%BB%B6React-Server-Components%E3%80%90%E8%AF%91%E6%96%87%E3%80%91/rsc4.png" alt="rsc4.png"><br><img src="/%E7%BF%BB%E8%AF%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%84%E4%BB%B6React-Server-Components%E3%80%90%E8%AF%91%E6%96%87%E3%80%91/rsc5.png" alt="rsc5.png"></p>
<p>上图的每个小旗子都代表一种常见的网页性能指标：</p>
<ol>
<li><strong>First Paint</strong>——用户看到的不再是白屏，而是一个已经渲染好的网页布局，但是内容仍然是缺失的，有时这个指标也称之为FCP（First Contentful Paint）。</li>
<li><strong>Page Interactive</strong>——React已经下载完成，应用已经完成水合，元素可以响应用户的交互，有时这也称之为TTI（Time To Interactive）。</li>
<li><strong>Content Paint</strong>——页面已经包含了用户关心的内容。我们已经获取到数据并渲染他们，有时这也称之为LCP（Largest Contentful Paint）。</li>
</ol>
<p>通过在服务器上完成初始渲染，我们能更快速的得到一个应用空壳，用户体验好了一点。毕竟这会给人一种内容正在加载的感觉。<br>在某些情况下，这种优化是有意义的。例如，用户可能只是在等待页头加载完成，然后点击导航链接。<br>但是你不觉得这个流程看起来很愚蠢么？当我看到SSR的流程图，我注意到为什么我们不能在服务器上就完成数据查询，而不是发送一个新的网络请求？为什么我们不在服务器进行初始化渲染时就执行数据库的查询？<br>换句话说，为什么我们不能上面的流程改为下面的这样：<br><img src="/%E7%BF%BB%E8%AF%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%84%E4%BB%B6React-Server-Components%E3%80%90%E8%AF%91%E6%96%87%E3%80%91/rsc6.png" alt="rsc6.png"></p>
<p>我们不再在服务器和客户端之间往返多次发送请求，而是在服务器上进行初始化渲染时就执行数据库的查询，将渲染好的有意义的UI直接发送给用户。<br>但是这到底应该如何做呢？<br>为了实现这个想法，我们需要给React一些代码，使其能只能在服务器上运行：数据库查询。但是这与React无关，甚至与SSR无关，目前我们所有的组件都可以同时在服务端和客户端渲染。<br>社区已经有很多该问题的解决方案，如基于React的框架Next.js和Gatsby，这些框架创建了自己的方式使得代码可以只运行在服务器上。<br>下面是Next.js的例子（使用了“Pages路由”）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import db from &#x27;imaginary-db&#x27;;</span><br><span class="line">// This code only runs on the server:</span><br><span class="line">export async function getServerSideProps() &#123;</span><br><span class="line">  const link = db.connect(&#x27;localhost&#x27;, &#x27;root&#x27;, &#x27;passw0rd&#x27;);</span><br><span class="line">  const data = await db.query(link, &#x27;SELECT * FROM products&#x27;);</span><br><span class="line">  return &#123;</span><br><span class="line">    props: &#123; data &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// This code runs on the server + on the client</span><br><span class="line">export default function Homepage(&#123; data &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;Trending Products&lt;/h1&gt;</span><br><span class="line">      &#123;data.map((item) =&gt; (</span><br><span class="line">        &lt;article key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;h2&gt;&#123;item.title&#125;&lt;/h2&gt;</span><br><span class="line">          &lt;p&gt;&#123;item.description&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/article&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们来分解一下这个例子：当服务器接收到请求时，<code>getServerSideProps</code>函数被调用，该函数返回<code>props</code>对象。然后该对象被传入组件，组件会先在服务器上渲染，然后在客户端水合。<br>这里的巧妙之处在于<code>getServerSideProps</code>不会在客户端执行。事实上该函数的代码不会被打包进客户端的JavaScript bundle文件中。<br>这种方法非常超前。老实说，这真的是太棒了。但是该方式也有一些缺点：</p>
<ol>
<li>这个策略只适合路由级别的组件，且必须是组件树的最顶层组件，并不适合所有组件。</li>
<li>每种框架都有自己实现方式，Next.js一种方式，Gatsby则是另外一种方式，Remix的方式也不同，还没有一个统一的标准。</li>
<li>所有的组件都会在客户端水合，即使有些组件没必要这么做。</li>
</ol>
<p>多年来，React团队一直在悄悄地解决这个问题，试图提出一种统一解决方案。这种方式被称之为服务端组件（React Server Components）。</p>
<h2 id="服务端组件介绍"><a href="#服务端组件介绍" class="headerlink" title="服务端组件介绍"></a>服务端组件介绍</h2><p>从另外一个纬度来说，服务端组件是一个全新的范式。在这个范式中，我们创建的组件只能运行在服务器上。这允许我们做一些特别的事情，例如在组件里执行数据库查询。<br>下面是一个简单的服务端组件示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import db from &#x27;imaginary-db&#x27;;</span><br><span class="line">async function Homepage() &#123;</span><br><span class="line">  const link = db.connect(&#x27;localhost&#x27;, &#x27;root&#x27;, &#x27;passw0rd&#x27;);</span><br><span class="line">  const data = await db.query(link, &#x27;SELECT * FROM products&#x27;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;Trending Products&lt;/h1&gt;</span><br><span class="line">      &#123;data.map((item) =&gt; (</span><br><span class="line">        &lt;article key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;h2&gt;&#123;item.title&#125;&lt;/h2&gt;</span><br><span class="line">          &lt;p&gt;&#123;item.description&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/article&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">export default Homepage;</span><br></pre></td></tr></table></figure>
<p>对一个使用React多年的人来说，这段代码让我感到困惑。但是等等！我忍不住发出尖叫。函数式组件不能是异步的，我们不能像这样直接在函数中编写有副作用的代码。<br>理解它的关键是服务端组件不会执行二次渲染，这些组件只会在服务器上执行一次来生成UI，渲染的结果被发送给客户端并不会再次更新。至于React，它需要关心的是这个渲染结果是不可变的，不会发生更新。<br>这意味着一大堆React相关的API与服务端组件都是不兼容的。例如，<strong>我们不能使用状态，因为状态会更新，但是服务端组件是不会二次渲染的。我们也不能使用<code>useEffect</code>，因为副作用函数只会在首次渲染之后执行。</strong>服务器组件不能在客户端运行。<br>这也意味着我们在规则方面有了更多的灵活性。例如，在传统的React中，我们需要把副作用代码放在<code>useEffect</code>或者事件处理函数中，这能保证这些副作用代码不会在每次渲染时都重复执行。但是如果组件只会渲染一次，我们就不用担心这个问题了。</p>
<p>服务端组件是很容易理解的，但是服务端组件的范式相对复杂。这是因为我们编写的仍然是常规的组件，但是他们组合的方式却容易让人感到困惑。在这个新的范式中，我们熟悉的传统组件是客户端组件，老实讲，我不喜欢这个名字。<br><strong>客户端组件的名字暗含着这种组件只能在客户端渲染，不过这种说法也不完全正确</strong>。客户端组件既可以在客户端渲染，也可以在服务端渲染。<br><img src="/%E7%BF%BB%E8%AF%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%84%E4%BB%B6React-Server-Components%E3%80%90%E8%AF%91%E6%96%87%E3%80%91/rsc7.png" alt="rsc7.png"></p>
<p>我知道这些术语看起来让人很困惑，以下是我的总结：</p>
<ul>
<li>服务端组件是一个新的范式名称。</li>
<li>在这个新的范式中，我们熟知的标准React组件被称之为客户端组件。这是对老的组件新称谓。</li>
<li>这个新的范式介绍了一种全新类型的组件，服务端组件。这种新的组件只能在服务端运行。他们的代码不会被打包进客户端JS bundle文件中，并且他们不会水合也不会在二次渲染。</li>
</ul>
<blockquote>
<h4 id="服务端组件-VS-服务端渲染"><a href="#服务端组件-VS-服务端渲染" class="headerlink" title="服务端组件 VS. 服务端渲染"></a>服务端组件 VS. 服务端渲染</h4><p>让我们弄清楚另一个容易混淆的概念：服务端组件不是服务端渲染的替代方案。你不应该把服务端组件看成是服务端渲染的2.0版本。<br>相反，我更愿意把他们看成是可以完美契合的两块拼图，这两种方式相互补充。<br>我们仍然需要依赖服务端渲染生成初始HTML，服务端组件是建立在服务端渲染之上的，这种技术能让我们将一些特定的组件代码从客户端的JS文件中剔除，确保这些代码只会服务端运行。<br>事实上，你也可以使用服务端组件，而不依赖服务端渲染。 尽管在实际项目中，同时使用这两种技术会得到更好的效果。React团队构建了一个服务端组件的Demo，而没有使用服务端渲染。可以<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/reactjs/server-components-demo">点击这里</a>查看。</p>
</blockquote>
<h3 id="环境兼容"><a href="#环境兼容" class="headerlink" title="环境兼容"></a>环境兼容</h3><p>通常情况下，如果你想使用新的React特性，你需要将React版本升级至最新版。通过执行<code>npm install react@latest</code>就能快速的升级至最新版本。但是在服务端组件却不是这样的。<br>我的理解是，服务端组件需要整合很多其他的技术，如打包工具，服务器和路由。<br>截止目前，使用服务端组件的唯一方式是使用Next.js 13.4+，并使用全新App Router方案。希望在不久的将来，更多基于React的框架能支持该特性。现在的状况有点令人尴尬，一个核心的React特性却只能在一个特殊的框架里使用。React文档中<a target="_blank" rel="noopener external nofollow noreferrer" href="https://react.dev/learn/start-a-new-react-project#bleeding-edge-react-frameworks">Bleeding-edge frameworks</a>章节列出了所有支持服务端组件的框架。我会时不时的看下该页面，看看会不会有新的方案可用。</p>
<h3 id="指定客户端组件"><a href="#指定客户端组件" class="headerlink" title="指定客户端组件"></a>指定客户端组件</h3><p>在新的服务端组件范式中，所有的组件默认都是服务端组件，所以我们不得不指定客户端组件。<br>指定客户端组件可以通过一个新的指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use client&#x27;;</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = React.useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">      Current value: &#123;count&#125;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">export default Counter;</span><br></pre></td></tr></table></figure>
<p>代码顶部语句<code>&#39;use client&#39;</code>指示该文件中的组件是一个客户端组件，客户端组件的代码会被打包进客户端JS bundle文件中。这样该组件就能在客户端重新渲染。<br>通过指令的方式将组件指定为客户端组件的方式看起来有些奇怪。但这不是首创，之前也有类似的指令，<code>&#39;use strict&#39;</code>就可以将JS转变为严格模式。<br>我们不需要通过<code>&#39;use server&#39;</code>将一个组件指定为服务端组件，在服务端组件的范式中，组件默认就是服务端组件。事实上，<code>&#39;use server&#39;</code>是用来指定服务端动作的，这是另外一个完全不同的特性，并不是本文介绍的主题。</p>
<blockquote>
<h4 id="什么组件应该是客户端组件？"><a href="#什么组件应该是客户端组件？" class="headerlink" title="什么组件应该是客户端组件？"></a>什么组件应该是客户端组件？</h4><p>你可能会有疑问，什么样的组件应该是客户端组件或服务端组件？<br>一个通用的准则：如果一个组件可以是服务端组件，那么它就应该是服务端组件。服务端组件更加简单，更加容易理解。并且服务端组件还有性能优势：因为服务端组件不会在客户端运行，代码也不会被打包进客户端的JS代码中。另外一个服务端组件的潜在益处是它可以提高页面的TTI（Page Interactive）指标。<br>不过我们的目标不是尽可能多的消除客户端组件，我们也不应该这么优化。不要忘记，React应用中的所有React组件都曾经是客户端组件。<br>如果你开始使用React服务端组件，你可能会发现这是非常直观的，有一些组件需要运行在客户端，因为这些组件使用了状态或者有副作用，你可以使用<code>&#39;use client&#39;</code>指令将这类组件指定为客户端组件。否则，你可以将它指定为服务端组件。</p>
</blockquote>
<h2 id="客户端组件边界"><a href="#客户端组件边界" class="headerlink" title="客户端组件边界"></a>客户端组件边界</h2><p>当我开始慢慢了解服务端组件，我的第一个疑问是：当组件的props发生变化该怎么办？<br>例如，假设我们有下面的服务端组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function HitCounter(&#123; hits &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Number of hits: &#123;hits&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们假设在服务端初始渲染时，<code>hits</code>的值是<code>0</code>。该组件会生成如下的HTML标签：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  Number of hits: 0</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>但是如果hits的值发生了变化该怎么办？假设这是个状态值，将它的值变为<code>1</code>之后，<code>HitCounter</code>组件会重新渲染。但是服务端组件是不会重新渲染的。问题是，服务端组件在隔离中是没有意义的。<br>假设我们有以下组件树：<br><img src="/%E7%BF%BB%E8%AF%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%84%E4%BB%B6React-Server-Components%E3%80%90%E8%AF%91%E6%96%87%E3%80%91/rsc8.png" alt="rsc8.png"></p>
<p>如果所有的组件都是服务端组件，那没什么疑问，所有的属性都不会更新，所有的组件都不会重新渲染。假设Article组件拥有hits状态值。为了使用状态值，我们需要将它转换为客户端组件。<br><img src="/%E7%BF%BB%E8%AF%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%84%E4%BB%B6React-Server-Components%E3%80%90%E8%AF%91%E6%96%87%E3%80%91/rsc9.png" alt="rsc9.png"><br>看到问题的所在了吗？当Article组件重新渲染时，该组件下的所有组件都会重新渲染，包括<code>HitCounter</code>和<code>Discussion</code>。如果这些组件是服务端组件，那么他们是不会重新渲染的。<br>为了避免这种不可能发生的状况，React团队制定了一条规则，客户端组件只能使用客户端组件。<code>&#39;use client&#39;</code>指令意味着<code>HitCounter</code>和<code>Discussion</code>组件实例将会被转换为客户端组件。<br>我突然意识到，服务端组件范式会创建一个类似于客户端边界的概念。最终的组件树像是下面这样的：<br><img src="/%E7%BF%BB%E8%AF%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%84%E4%BB%B6React-Server-Components%E3%80%90%E8%AF%91%E6%96%87%E3%80%91/rsc10.png" alt="rsc10.png"><br>当我们在Article组件中加入<code>&#39;use client&#39;</code>指令，就会创建一个客户端边界，在这个边界之内的所有组件都会被隐式的转换为客户端组件，尽管<code>HitCounter</code>组件没有<code>&#39;use client&#39;</code>指令，在这种特殊的情形之下，这些组件仍然会水合或者重新渲染。<br>这意味着我们没必要向所有需要运行在客户端的组件添加<code>&#39;use client&#39;</code>指令。实际使用中，我们只需要在创建新的客户端边界时加上该指令。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>当我第一次知道客户端组件不会渲染服务端组件，我觉得这会有一点限制。如果我想在应用的顶层组件中使用状态怎么办？是不是意味着所有的组件都会被转换为客户端组件？<br>在大多数的情况下，我们可以通过重建组件树的方式解决该限制。解释起来比较困难，我们使用下面的例子来演示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use client&#x27;;</span><br><span class="line">import &#123; DARK_COLORS, LIGHT_COLORS &#125; from &#x27;@/constants.js&#x27;;</span><br><span class="line">import Header from &#x27;./Header&#x27;;</span><br><span class="line">import MainContent from &#x27;./MainContent&#x27;;</span><br><span class="line">function Homepage() &#123;</span><br><span class="line">  const [colorTheme, setColorTheme] = React.useState(&#x27;light&#x27;);</span><br><span class="line">  const colorVariables = colorTheme === &#x27;light&#x27;</span><br><span class="line">    ? LIGHT_COLORS</span><br><span class="line">    : DARK_COLORS;</span><br><span class="line">  return (</span><br><span class="line">    &lt;body style=&#123;colorVariables&#125;&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;MainContent /&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们需要用到React状态来允许用户切换暗黑和白天模式，这个功能必须是在组件树的顶层组件，以方便我们可以设置<code>&lt;body&gt;</code>标签上的CSS变量。为了使用React状态，我们需要把<code>Homepage</code>组件转换为客户端组件，但是又因为这个组件是应用的顶层组件，这会使得该组件下的其他组件<code>Header</code>和<code>MainContent</code>，也被隐式的转换为客户端组件。<br>为了解决这个问题，我们把颜色状态管理的代码提取到单独的组件中去，创建一个新的组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// /components/ColorProvider.js</span><br><span class="line">&#x27;use client&#x27;;</span><br><span class="line">import &#123; DARK_COLORS, LIGHT_COLORS &#125; from &#x27;@/constants.js&#x27;;</span><br><span class="line">function ColorProvider(&#123; children &#125;) &#123;</span><br><span class="line">  const [colorTheme, setColorTheme] = React.useState(&#x27;light&#x27;);</span><br><span class="line">  const colorVariables = colorTheme === &#x27;light&#x27;</span><br><span class="line">    ? LIGHT_COLORS</span><br><span class="line">    : DARK_COLORS;</span><br><span class="line">  return (</span><br><span class="line">    &lt;body style=&#123;colorVariables&#125;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到Homepage组件，我们将代码改成下面的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// /components/Homepage.js</span><br><span class="line">import Header from &#x27;./Header&#x27;;</span><br><span class="line">import MainContent from &#x27;./MainContent&#x27;;</span><br><span class="line">import ColorProvider from &#x27;./ColorProvider&#x27;;</span><br><span class="line">function Homepage() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ColorProvider&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;MainContent /&gt;</span><br><span class="line">    &lt;/ColorProvider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以删除<code>Homepage</code>组件中的<code>&#39;use client&#39;</code>指令了，因为它已经不需要再使用状态或其他客户端React相关的功能了。这也意味着<code>Header</code>和<code>MainContent</code>组件不会再被转换为客户端组件。<br>等一下！<code>ColorProvider</code>是一个客户端组件，它是<code>Header</code>和<code>MainContent</code>组件的父组件，不论哪种方式，他仍然是组件树的顶层组件，不对么？<br>然而，当涉及到客户端边界时，父子关系并不是关键。真正引入<code>Header</code>和<code>MainContent</code>组件的是<code>Homepage</code>组件。这也意味着<code>Homepage</code>组件影响了<code>Header</code>和<code>MainContent</code>组件的props。<br>记住一点，我们要解决的问题是服务端组件不能二次渲染，所以他们的props不会更新，在这个例子中<code>Homepage</code>决定了<code>Header</code>和<code>MainContent</code>的props，并且<code>Homepage</code>是服务端组件，所以这个解决方案是正常的。<br>这有点难以理解，即使是对于有多年React经验的我来说，这也十分令人困惑。理解这个解决方案需要非常丰富的React实践经验。<br><strong>更准确的说，<code>&#39;use client&#39;</code>是工作在文件或模块级别的，任何在客户端组件文件中被导入的模块或者文件都会被转换为客户端组件。当打包器打包代码时，他会遵循这个原则。</strong></p>
<blockquote>
<h4 id="更改颜色状态？"><a href="#更改颜色状态？" class="headerlink" title="更改颜色状态？"></a>更改颜色状态？</h4><p>你可能注意到在上面的例子中，是没法更改颜色主题的，并没有代码调用<code>setColorTheme</code>。<br>这是因为为了演示，我尽可能得保持代码简单，所以没有添加这部分代码。完整的例子应该是使用React Context，以便任何后代组件都能够修改主题状态值。只要消费context值的组件是客户端组件，这个例子就能正常工作。</p>
</blockquote>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>接下来，我们探究一下这背后的工作原理，当我们使用服务端组件时，输出是什么样的？我们到底生成了什么？<br>我们先从最简单的React应用开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Homepage() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      Hello world!</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在服务端组件的范式中，所有的组件默认情况下都是服务端组件。由于我们没有将这个组件明确指定成客户端组件（或者将它放在客户端边界之内），所以这个组件会在服务器上渲染。<br>当我们在浏览器中访问这个应用时，我们接收到的HTML文档看起来像是下面这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Hello world!&lt;/p&gt;</span><br><span class="line">    &lt;script src=&quot;/static/js/bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      self.__next[&#x27;$Homepage-1&#x27;] = &#123;</span><br><span class="line">        type: &#x27;p&#x27;,</span><br><span class="line">        props: null,</span><br><span class="line">        children: &quot;Hello world!&quot;,</span><br><span class="line">      &#125;;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了使示例更容易理解，我重新修改了下这里的代码，例如，真实代码会使用JSON字符串数组，这可以帮助减小HTML文档的体积。<br>我还移除了一些不中要的标签，如<head>。</p>
</blockquote>
<p>我们看到HTML文档包含了由React生成的UI：“Hello World!”段落，这要归功于服务端渲染，而不是服务端组件。<code>&lt;p&gt;</code>标签下面是一个<code>&lt;script&gt;</code>标签，它加载了我们打包的JS文件，该文件包括React依赖和我们应用客户端组件的代码。由于<code>Homepage</code>是服务端组件所以它的代码不会被打包进JS文件中。最后，还有一个<code>&lt;script&gt;</code>标签有一些内联的JS代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.__next[&#x27;$Homepage-1&#x27;] = &#123;</span><br><span class="line">  type: &#x27;p&#x27;,</span><br><span class="line">  props: null,</span><br><span class="line">  children: &quot;Hello world!&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这部分代码很有趣，本质上，这里所做的事情就好像在告诉React“我知道你缺少了<code>Homepage</code>组件的代码，但是不要担心，这里就是渲染这个组件所需要的信息”。通常情况下，当React在客户端水合时，它会立即渲染所有组件，构建应用的虚拟组件树，但是他不会渲染服务端组件，因为打包的JS文件不包含这些组件的代码。<br>这些值是服务端已经渲染好的DOM的虚拟DOM，当React在客户端加载时，会重新复用这些描述性信息，而不是重新生成这些虚拟DOM。<br>这就是为什么上面那个<code>ColorProvider</code>组件能正常工作。<code>Header</code>和<code>MainContent</code>组件的输出通过children属性传入<code>ColorProvider</code>组件。该组件是可以二次渲染的，但是数据是已经由服务器生成的静态数据。<br>如果你好奇服务端组件的数据信息是如何被序列化并通过网络发送给客户端的，可以使用<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.alvar.dev/blog/creating-devtools-for-react-server-components">RSC Devtools</a>查看。</p>
<blockquote>
<h4 id="服务端组件不需要服务器"><a href="#服务端组件不需要服务器" class="headerlink" title="服务端组件不需要服务器"></a>服务端组件不需要服务器</h4><p>上文我提到服务端渲染是个综合的概念，包括很多不同的渲染策略：</p>
<ul>
<li>静态渲染：在应用部署的构建中生成HTML</li>
<li>动态渲染：在用户请求页面的时候按需生成HTML<h4 id="服务端组件兼容上面所有的渲染策略"><a href="#服务端组件兼容上面所有的渲染策略" class="headerlink" title="服务端组件兼容上面所有的渲染策略"></a>服务端组件兼容上面所有的渲染策略</h4>当我们的服务端组件在Node.js运行时中被渲染的时候，返回的JS对象会被创建。这个过程既可以发生在用户请求时，也可以发生在应用构建时。<br>这意味着我们可以在没有服务器的情况下使用服务端组件。我们可以生成一堆静态的HTML文件并将他们放在某个服务器上。事实上，这就是Next.js的App Router默认策略。除非我们的确需要按需生成，否则所有的工作都可以提前在构建时就完成。</li>
</ul>
</blockquote>
<blockquote>
<h4 id="完全不需要React？"><a href="#完全不需要React？" class="headerlink" title="完全不需要React？"></a>完全不需要React？</h4><p>你可能会疑惑：如果我们的应用不包含任何客户端组件，我们还需要下载React框架代码么？我们能使用React服务端组件构建一个真正的纯静态的、没有JS的站点么？<br>事实是，React的服务端组件目前只能在Next.js框架中使用，这个框架中包含许多需要运行在客户端的代码，来处理像路由这样的功能。<br>与直觉相反，在Next.js中这种非纯静态的模式反而有更好的用户体验，例如在Next.js的路由中，点击Link的的处理速度往往比传统的<code>&lt;a&gt;</code>标签更快，因为它不需要再加载完整的HTML文档。<br>已经构建好的Next.js应用是可以在JS文件还在下载时正常工作的，但是文件下载好之后，应用的响应速度会更快。</p>
</blockquote>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>React服务端组件是第一个正式的方式来在React中运行服务器专属的代码。然而，就像我上面提到的，在React生态中，这并不是全新的技术。Next.js甚至在2016年就实现了在运行服务端专属的代码。<br>最大的区别是，我们之前没法在React组件中运行服务端专属的代码。<br>服务端组件最大的优势就是性能，因为服务端组件不会被打包进JS代码中，这可以减小下载的JS文件体积，也可以减少需要水合的组件数量。<br><img src="/%E7%BF%BB%E8%AF%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%84%E4%BB%B6React-Server-Components%E3%80%90%E8%AF%91%E6%96%87%E3%80%91/rsc11.png" alt="rsc11.png"><br><img src="/%E7%BF%BB%E8%AF%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%84%E4%BB%B6React-Server-Components%E3%80%90%E8%AF%91%E6%96%87%E3%80%91/rsc12.png" alt="rsc12.png"></p>
<p>老实说Next.js框架至少在页面的FID方面，已经有一点性能上的提升了。如果你严格遵守了HTML的语义化规范，大多数应用甚至在水合还没有完成时就可以进行交互。例如Link是可点击的，表单可以提交，accordions可以打开或关闭。对于大多数项目来说，花几秒钟的时间进行水合是可以接受的。<br>但是我还发现了一些真正酷的东西：利用服务端组件，我们不再需要在功能和JS bundle体积之间做任何的妥协。<br>例如，大部分技术博客需要使用代码语法高亮的插件。在这个博客中，我用了Prism。代码的样式看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function exampleJavaScriptFunction(param) &#123;</span><br><span class="line">  return &quot;Hello world!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语法高亮插件为了支持所有的主流编程语言，通常会占用若干兆的体积。这已经远大于我们的JS bundle文件。所以为了减小库的体积，我们不得不移除一些不那么重要的语言的支持。<br>但是加入我们可以在服务端组件中使用语法高亮插件，这个库的代码就不会被打包进JS bundle中。这样我们就不需要做任何的妥协。我们可以使用这个库的所有功能。<br>这就是<a target="_blank" rel="noopener external nofollow noreferrer" href="https://bright.codehike.org/">Bright</a>库的原理，一个可以在服务端组件中使用的现代语法高亮插件。<br><img src="/%E7%BF%BB%E8%AF%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%84%E4%BB%B6React-Server-Components%E3%80%90%E8%AF%91%E6%96%87%E3%80%91/rsc13.png" alt="rsc13.png"></p>
<p>这就是React服务端组件令我兴奋的地方，那些以前在JS bundle中运行成本过高的代码，现在可以放在服务端运行，并且也不会是我们的JS bundle体积增加，以提供更好的用户体验。<br>不仅在性能和用户体验方面。使用RSC一段时间后，我对服务端组件的简单易用深有体会。在服务端组件中，我们不再需要担心数组依赖、闭包、数据更新等一些由数据变化引起的复杂逻辑。<br>不过现在，还为时尚早，React服务端组件发布beta版也就是几个月之前的事情。我很期待看看后面几年会发生的事情，社区也会利用这个新的范式，创造出新的解决方案，比如Bright。对于React开发者来说，这是值得兴奋的时刻。</p>
<h2 id="完整解决方案"><a href="#完整解决方案" class="headerlink" title="完整解决方案"></a>完整解决方案</h2><p>React服务端组件令人兴奋，但是它也仅仅是现代React拼图中的一部分。如果我们将React服务端组件技术和Suspense已经最新的流式SSR架构结合起来，事情会变得非常有趣。这可以允许我们实现更棒的事情：<br><img src="/%E7%BF%BB%E8%AF%91/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%84%E4%BB%B6React-Server-Components%E3%80%90%E8%AF%91%E6%96%87%E3%80%91/rsc14.png" alt="rsc14.png"><br>这个已经超出本文的主题，不过你可以<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/reactwg/react-18/discussions/37">点击这里</a>学习流式渲染。<br>React的服务端组件是一个重大的范式创新。我个人非常期待后面的更新，也非常期待React社区能够利用服务端组件创造出更多像Bright这样优秀的工具。</p>


                

                <ul class="pager">
                    
                        <li class="previous"><a href="/翻译/用JS实现一个极简编译器【译文】.html">&larr;  上一篇</a></li>
                    
                    
                        <li class="next"><a href="/学习/使用Back-Forward-Cache加速页面导航.html">下一篇 &rarr;</a></li>
                    
                </ul>
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>


    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/neilning-xc" rel="external nofollow noreferrer" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    
                        <li>
                            <a href="mailto:ningcoder@foxmail.com" rel="external nofollow noreferrer" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-envelope-o fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2025 Neil Ning<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/" rel="external nofollow noreferrer">Clean Blog</a> from <a href="http://startbootstrap.com/" rel="external nofollow noreferrer" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/" rel="external nofollow noreferrer">Hexo</a> by <a href="http://www.codeblocq.com/" rel="external nofollow noreferrer" target="_blank">Jonathan Klughertz</a></p>
                <!-- <p class="copyright text-muted"><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.miitbeian.gov.cn/">豫ICP备19003046号</a></p> -->
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//lib.baomitu.com/jquery/2.1.4/jquery.min.js"></script>

<!-- Bootstrap -->
<script src="//lib.baomitu.com/twitter-bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//lib.baomitu.com/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>