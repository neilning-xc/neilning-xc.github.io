<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="Tell the world with code"/>
    

    <!--Author-->
    
        <meta name="author" content="Neil Ning"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="用户订阅【译】"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="Tell the world with code"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Neil的博客"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="https://neilning-xc.github.io/img/banner.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="https://neilning-xc.github.io/img/banner.jpg"/>
    

    <!-- Title -->
    
    <title>用户订阅【译】 - Neil的博客</title>

    <!-- Bootstrap Core CSS -->
    <link href="//lib.baomitu.com/twitter-bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//lib.baomitu.com/featherlight/1.3.5/featherlight.min.css" rel="stylesheet"/>

    <!-- Google Analytics -->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPEMLKFYYW"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-ZPEMLKFYYW');
    </script>



    <!-- favicon -->
    

<meta name="generator" content="Hexo 5.4.2"></head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Neil的博客</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                首页
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                归档
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                标签
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                分类
                            
                        </a>
                    </li>
                
                    <li>
                        <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/neilning-xc/neilning-xc.github.io">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header post-header" style="background-image: url('用户订阅【译】/bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>用户订阅【译】</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                            Posted by Neil Ning on
                        
                        
                            2023-07-21
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/subscription/">#subscription</a> <a href="/tags/push-subscription/">#push subscription</a> <a href="/tags/applicationServerKey/">#applicationServerKey</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/翻译/">翻译</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该文章翻译自web.dev的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://web.dev/notifications/">Notifications</a>系列文章，本篇文章原文链接<a target="_blank" rel="noopener external nofollow noreferrer" href="https://web.dev/push-notifications-subscribing-a-user/">点击这里</a></p>
<p>消息推送的第一步是获得用户授权，获得用户授权后我们可以得到<code>PushSubscription</code>对象，JavaScript API的调用方式简单直接，让我们一起来看下具体如何实现。</p>
<h2 id="相关功能检测"><a href="#相关功能检测" class="headerlink" title="相关功能检测"></a>相关功能检测</h2><p>首先我们要检查当前浏览器是否支持消息推送，包括以下两个API的检查：</p>
<ol>
<li>检查navigator对象的serviceWorker属性</li>
<li>检查window对象的PushManager属性</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (!(&#x27;serviceWorker&#x27; in navigator)) &#123;</span><br><span class="line">  // Service Worker isn&#x27;t supported on this browser, disable or hide UI.</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!(&#x27;PushManager&#x27; in window)) &#123;</span><br><span class="line">  // Push isn&#x27;t supported on this browser, disable or hide UI.</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前越来越到的浏览器都在支持这两个功能，特性检查对消息推送或者构建渐进式增强的应用是个好的习惯。</p>
<h2 id="注册service-worker"><a href="#注册service-worker" class="headerlink" title="注册service worker"></a>注册service worker</h2><p>service worker和push都支持之后，下一步就是注册service worker。注册service worker过程就是告诉浏览器service worker文件的位置。该文件是一个普通的JavaScript文件，但是浏览器允许在这个文件内访问包括推送在内的service worker API，更准确的说，浏览器会在service worker环境运行该JS文件。<br>我们调用<code>navigator.serviceWorker.register()</code>来注册service worker：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function registerServiceWorker() &#123;</span><br><span class="line">  return navigator.serviceWorker</span><br><span class="line">    .register(&#x27;/service-worker.js&#x27;)</span><br><span class="line">    .then(function (registration) &#123;</span><br><span class="line">      console.log(&#x27;Service worker successfully registered.&#x27;);</span><br><span class="line">      return registration;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(function (err) &#123;</span><br><span class="line">      console.error(&#x27;Unable to register service worker.&#x27;, err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数就是告诉浏览器service worker文件的位置，上面的这个例子中service worker文件是<code>/service-worker.js</code>，调用register函数之后浏览器在背后完成了如下几个步骤：</p>
<ol>
<li>下载service worker文件</li>
<li>运行该JS文件</li>
<li>如果运行正常没有错误，promise将会正常resolve，否则promise将会被reject</li>
</ol>
<p>如果register reject，可以在Chrome DevTools中检查有没有代码拼写错误。如果register正常resolve，将会返回<code>ServiceWorkerRegistration</code>对象，后续我们要通过该对象访问<a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/API/PushManager">PushManager API</a></p>
<h2 id="获取权限"><a href="#获取权限" class="headerlink" title="获取权限"></a>获取权限</h2><p>注册service worker完成之后，下一步就是要获取消息推送的相关权限。获取权限的API相对简单，下面的例子将回调函数改为返回一个Promise对象（<a target="_blank" rel="noopener external nofollow noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Notification/requestPermission_static">原因点击这里</a>），之所以这么实现是因为我们无法知道当前浏览器实现了哪个版本的API，所以我们同时处理了这两种情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function askPermission() &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    const permissionResult = Notification.requestPermission(function (result) &#123;</span><br><span class="line">      resolve(result);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    if (permissionResult) &#123;</span><br><span class="line">      permissionResult.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).then(function (permissionResult) &#123;</span><br><span class="line">    if (permissionResult !== &#x27;granted&#x27;) &#123;</span><br><span class="line">      throw new Error(&quot;We weren&#x27;t granted permission.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，最核心的代码是调用<code>Notification.requestPermission()</code>，调用该方法会展示一个提示框给用户：<br><img src="/%E7%BF%BB%E8%AF%91/%E7%94%A8%E6%88%B7%E8%AE%A2%E9%98%85%E3%80%90%E8%AF%91%E3%80%91/prompt.jpg" alt="prompt.jpg"></p>
<p>用户点击允许、阻止或者直接关闭该提示框，返回的permissionResult值依次是<code>&#39;granted&#39;</code>，<code>&#39;denied&#39;</code>，<code>&#39;default&#39;</code>，上面的例子中，用户点击允许，Promise对象才会resolve，否则将会抛出异常并reject。<br>你需要处理的一个边界情况是用户点击拒绝。用户一旦点击拒绝，你的web应用将无法向用户询问该权限，除非用户手动设置。但是该设置项在浏览器中隐藏较深。所以请仔细考虑获取用户权限的时机，因为用户一旦拒绝，他将很难再次给予web应用该权限。好消息如果用户知道他们为什么会被询问该权限，大多数用户是很乐意点击允许的。后面我们将演示那些主流网站是如何向用户征求该权限的。</p>
<h2 id="使用PushManager订阅用户"><a href="#使用PushManager订阅用户" class="headerlink" title="使用PushManager订阅用户"></a>使用PushManager订阅用户</h2><p>一旦我们注册完service worker并获取了用户的授权，我们就可以通过调用<code>registration.pushManager.subscribe()</code>订阅用户。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function subscribeUserToPush() &#123;</span><br><span class="line">  return navigator.serviceWorker</span><br><span class="line">    .register(&#x27;/service-worker.js&#x27;)</span><br><span class="line">    .then(function (registration) &#123;</span><br><span class="line">      const subscribeOptions = &#123;</span><br><span class="line">        userVisibleOnly: true,</span><br><span class="line">        applicationServerKey: urlBase64ToUint8Array(</span><br><span class="line">          &#x27;BEl62iUYgUivxIkv69yViEuiBIa-Ib9-SkvMeAtA3LFgDzkrxZJjSgSnfckjBJuBkr3qBUYIHBQFLXYp5Nksh8U&#x27;,</span><br><span class="line">        ),</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      return registration.pushManager.subscribe(subscribeOptions);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(function (pushSubscription) &#123;</span><br><span class="line">      console.log(</span><br><span class="line">        &#x27;Received PushSubscription: &#x27;,</span><br><span class="line">        JSON.stringify(pushSubscription),</span><br><span class="line">      );</span><br><span class="line">      return pushSubscription;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>subscribe()</code>方法时，我们传入了一个options对象，该对象由一些可选项和必选项组成，我们来看一下选项中各参数的含义。</p>
<h3 id="userVisibleOnly选项"><a href="#userVisibleOnly选项" class="headerlink" title="userVisibleOnly选项"></a><code>userVisibleOnly</code>选项</h3><p>当推送功能刚被加入到浏览器时，我们还不确定是否应该允许开发者推送消息但不展示通知，即我们所说的静默推送，因为用户可能没法知道浏览器在背后做些什么工作。所以我们会担心开发者可能做一些恶意的事情，比如在用户不知情的情况下，跟踪用户的位置信息。为了避免这种情况，并给规范制定者时间来考虑如何更好的支持这个功能，我们加入了<code>userVisibleOnly</code>选项，true表示web应用每次收到推送消息时都会展示通知。不过现在你必须传入true，如果没有传入该选项或者传入false，将会产生以下错误。</p>
<p><em>Chrome currently only supports the Push API for subscriptions that will result in user-visible messages. You can indicate this by calling pushManager.subscribe({userVisibleOnly: true}) instead. See <a target="_blank" rel="noopener external nofollow noreferrer" href="https://goo.gl/yqv4Q4">https://goo.gl/yqv4Q4</a> for more details.</em></p>
<p>从目前的情况来看，在Chrome中静默推送可能永远也不会被实现。不过，协议制定者们也在探讨其他方式，如在web app上允许一定数量的静默推送。</p>
<h3 id="applicationServerKey选项"><a href="#applicationServerKey选项" class="headerlink" title="applicationServerKey选项"></a><code>applicationServerKey</code>选项</h3><p>在之前的章节中，我们简单提到过应用服务器密钥（application server keys）。该密钥使得推送服务知道哪个应用正在订阅用户，并确保同一个应用能够发消息给用户。在你的应用中，应用服务器密钥是一个唯一的公钥和私钥的密钥对。私钥必须存储在你的应用服务器上，公钥可以公开给用户。<br>调用subscribe()方法时，传给applicationServerKey选项的是应用的公钥，订阅用户时，浏览器会将公钥传给推送服务。这个意味着推送服务会将公钥和用户的PushSubscription对象建立关联关系。<br>下面的流程图演示了以上几个步骤：</p>
<ol>
<li>在浏览器中调用<code>subscribe()</code>方法，浏览器会把应用服务器公钥传给推送服务。</li>
<li>浏览器向推送服务发起网络请求，推送服务会生成endpoint，该endpoint与你提供的公钥建立关联，同时会将该endpoint返回给浏览器。</li>
<li>浏览器将该endpoint加入到PushSubscription对象中，然后subscribe()方法会返回该对象。</li>
</ol>
<p><img src="/%E7%BF%BB%E8%AF%91/%E7%94%A8%E6%88%B7%E8%AE%A2%E9%98%85%E3%80%90%E8%AF%91%E3%80%91/app-key.jpg" alt="app-key.jpg"></p>
<p>在服务器端，当你推送消息时，你需要向推送服务发起请求，这个请求的请求头必须包含<strong>Authorization</strong>字段，该字段要求使用私钥对你发送的数据进行签名。当推送服务收到推送的消息，他会使用与endpoint相关联的公钥验证已签名的<strong>Authorization</strong>字段，验证通过，推送服务会知道改应用服务器拥有匹配的私钥。这也是一个基本的安全措施来阻止推送服务查看应用发送给用户的消息。<br><img src="/%E7%BF%BB%E8%AF%91/%E7%94%A8%E6%88%B7%E8%AE%A2%E9%98%85%E3%80%90%E8%AF%91%E3%80%91/serverapp-key.jpg" alt="serverapp-key.jpg"></p>
<p>技术上来说，<code>applicationServerKey</code>是可选的，但在Chrome上他是必须的。其他浏览器如Firefox还不需要该参数，不过未来可能会支持。<br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://datatracker.ietf.org/doc/html/draft-thomson-webpush-vapid">VAPID spec</a>定义了application server key的规范，任何时候你看到”application server keys” 或者 “VAPID keys”，他们指得是同一个东西。</p>
<h3 id="如何创建应用服务器密钥"><a href="#如何创建应用服务器密钥" class="headerlink" title="如何创建应用服务器密钥"></a>如何创建应用服务器密钥</h3><p>你可以访问<a target="_blank" rel="noopener external nofollow noreferrer" href="https://web-push-codelab.glitch.me/"> web-push-codelab.glitch.me</a>创建应用服务器密钥，或者通过<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/web-push-libs/web-push#command-line">web-push的命令行</a>工具来生成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g web-push</span><br><span class="line">$ web-push generate-vapid-keys</span><br></pre></td></tr></table></figure>
<p>对你的应用来说，你只需要创建一次该密钥，并确保私钥的安全。</p>
<h3 id="权限和subscribe"><a href="#权限和subscribe" class="headerlink" title="权限和subscribe()"></a>权限和subscribe()</h3><p>当你的应用没有显示通知的权限时，调用subscribe()方法浏览器会显示权限询问提示框。这在UI交互中调用该函数是很有用的，但是如果你想更好的控制这个过程，你最好使用前面提到的<code>Notification.requestPermission()</code>API来获取权限。</p>
<h3 id="什么是PushSubscription对象"><a href="#什么是PushSubscription对象" class="headerlink" title="什么是PushSubscription对象"></a>什么是PushSubscription对象</h3><p>调用subscribe()函数，传入了一些选项，函数resolve返回的对象就是PushSubscription对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function subscribeUserToPush() &#123;</span><br><span class="line">  return navigator.serviceWorker</span><br><span class="line">    .register(&#x27;/service-worker.js&#x27;)</span><br><span class="line">    .then(function (registration) &#123;</span><br><span class="line">      const subscribeOptions = &#123;</span><br><span class="line">        userVisibleOnly: true,</span><br><span class="line">        applicationServerKey: urlBase64ToUint8Array(</span><br><span class="line">          &#x27;BEl62iUYgUivxIkv69yViEuiBIa-Ib9-SkvMeAtA3LFgDzkrxZJjSgSnfckjBJuBkr3qBUYIHBQFLXYp5Nksh8U&#x27;,</span><br><span class="line">        ),</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      return registration.pushManager.subscribe(subscribeOptions);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(function (pushSubscription) &#123;</span><br><span class="line">      console.log(</span><br><span class="line">        &#x27;Received PushSubscription: &#x27;,</span><br><span class="line">        JSON.stringify(pushSubscription),</span><br><span class="line">      );</span><br><span class="line">      return pushSubscription;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PushSubscription</code>对象包含所有必备的信息，用于向用户发送消息，使用<code>JSON.stringify()</code>函数打引出该对象的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;endpoint&quot;: &quot;https://some.pushservice.com/something-unique&quot;,</span><br><span class="line">  &quot;keys&quot;: &#123;</span><br><span class="line">    &quot;p256dh&quot;:   &quot;BIPUL12DLfytvTajnryr2PRdAgXS3HGKiLqndGcJGabyhHheJYlNGCeXl1dn18gSJ1WAkAPIxr4gK0_dQds4yiI=&quot;,</span><br><span class="line">   &quot;auth&quot;:&quot;FPssNDTKnInHVndSTdbKFw==&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>endpoint</code>字段是推送服务的URL，推送服务时，需要向该URL发送网络请求。<code>keys</code>对象包含的密钥是用来加密发送的消息，这个后面会讲到。</p>
<h2 id="将subscription对象发送给服务器"><a href="#将subscription对象发送给服务器" class="headerlink" title="将subscription对象发送给服务器"></a>将subscription对象发送给服务器</h2><p>一旦你拿到subscription对象，你需要将该对象发送给服务器，你直接调用<code>JSON.stringify()</code>将对象转换成字符串，或者手动处理各个对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const subscriptionObject = &#123;</span><br><span class="line">  endpoint: pushSubscription.endpoint,</span><br><span class="line">  keys: &#123;</span><br><span class="line">    p256dh: pushSubscription.getKeys(&#x27;p256dh&#x27;),</span><br><span class="line">    auth: pushSubscription.getKeys(&#x27;auth&#x27;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// The above is the same output as:</span><br><span class="line"></span><br><span class="line">const subscriptionObjectToo = JSON.stringify(pushSubscription);</span><br></pre></td></tr></table></figure>
<p>然后需要在前端页面将对象发送给服务端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function sendSubscriptionToBackEnd(subscription) &#123;</span><br><span class="line">  return fetch(&#x27;/api/save-subscription/&#x27;, &#123;</span><br><span class="line">    method: &#x27;POST&#x27;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    body: JSON.stringify(subscription),</span><br><span class="line">  &#125;)</span><br><span class="line">    .then(function (response) &#123;</span><br><span class="line">      if (!response.ok) &#123;</span><br><span class="line">        throw new Error(&#x27;Bad status code from server.&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return response.json();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(function (responseData) &#123;</span><br><span class="line">      if (!(responseData.data &amp;&amp; responseData.data.success)) &#123;</span><br><span class="line">        throw new Error(&#x27;Bad response from server.&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node服务器收到该请求，需要将该对象存入数据库中，以便后续使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">app.post(&#x27;/api/save-subscription/&#x27;, function (req, res) &#123;</span><br><span class="line">  if (!isValidSaveRequest(req, res)) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return saveSubscriptionToDatabase(req.body)</span><br><span class="line">    .then(function (subscriptionId) &#123;</span><br><span class="line">      res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);</span><br><span class="line">      res.send(JSON.stringify(&#123;data: &#123;success: true&#125;&#125;));</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(function (err) &#123;</span><br><span class="line">      res.status(500);</span><br><span class="line">      res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);</span><br><span class="line">      res.send(</span><br><span class="line">        JSON.stringify(&#123;</span><br><span class="line">          error: &#123;</span><br><span class="line">            id: &#x27;unable-to-save-subscription&#x27;,</span><br><span class="line">            message:</span><br><span class="line">              &#x27;The subscription was received but we were unable to save it to our database.&#x27;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;),</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>将PushSubscription对象保存如数据库后，我们就能随时向用户推送消息了。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>到此可能会有如下常见问题：<br>Q: 我可以更改推送服务么？<br>A: 不可以，推送服务是由浏览器厂商决定的，调用subscribe()方法时，我们能看到推送服务的地址，浏览器向推送服务发送网络请求，并获取到PushSubscription对象</p>
<p>Q: 每个浏览器都有不同的推送服务，他们会用不同的API么？<br>A: 所有的推送服务都应该有相同的API，API的规范就是Web Push Protocol，它描述了发送消息时发起网络请求的各种细节。</p>
<p>Q: 如果在桌面设备订阅了用户，在移动设备上，用户也会被自动订阅么？<br>A: 很遗憾，不会。用户必须在所有希望收到消息推送的设备上单独订阅，并且在所有设备上给予授权。</p>


                

                <ul class="pager">
                    
                        <li class="previous"><a href="/翻译/获取权限的最佳用户体验【译】.html">&larr;  上一篇</a></li>
                    
                    
                        <li class="next"><a href="/翻译/推送通知是如何工作的【译】.html">下一篇 &rarr;</a></li>
                    
                </ul>
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>


    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/neilning-xc" rel="external nofollow noreferrer" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    
                        <li>
                            <a href="mailto:ningcoder@foxmail.com" rel="external nofollow noreferrer" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-envelope-o fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2025 Neil Ning<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/" rel="external nofollow noreferrer">Clean Blog</a> from <a href="http://startbootstrap.com/" rel="external nofollow noreferrer" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/" rel="external nofollow noreferrer">Hexo</a> by <a href="http://www.codeblocq.com/" rel="external nofollow noreferrer" target="_blank">Jonathan Klughertz</a></p>
                <!-- <p class="copyright text-muted"><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.miitbeian.gov.cn/">豫ICP备19003046号</a></p> -->
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//lib.baomitu.com/jquery/2.1.4/jquery.min.js"></script>

<!-- Bootstrap -->
<script src="//lib.baomitu.com/twitter-bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//lib.baomitu.com/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>